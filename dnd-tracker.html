<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DnD Combat Tracker</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #3498db;
        }

        .section h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .form-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        input, select, button {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #3498db;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
            font-weight: bold;
        }

        button:hover {
            background: #2980b9;
        }

        .btn-danger {
            background: #e74c3c;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #27ae60;
        }

        .btn-success:hover {
            background: #219a52;
        }

        .btn-warning {
            background: #f39c12;
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .btn-purple {
            background: #9b59b6;
        }

        .btn-purple:hover {
            background: #8e44ad;
        }

        .btn-secondary {
            background: #95a5a6;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .character-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(450px, 1fr));
            gap: 15px;
        }

        .character-card {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border: 2px solid #ecf0f1;
        }

        .character-card.active {
            border-color: #f39c12;
            background: #fff8e1;
        }

        .character-card.played {
            opacity: 0.6;
            background: #f5f5f5;
        }

        .character-card.dragging {
            opacity: 0.5;
            cursor: move;
        }

        .character-card.drag-over {
            border-top: 3px solid #3498db;
        }

        .character-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .character-name {
            font-weight: bold;
            font-size: 1.1em;
            color: #2c3e50;
            cursor: pointer;
        }

        .character-name:hover {
            color: #3498db;
        }

        .character-type {
            background: #ecf0f1;
            padding: 3px 8px;
            border-radius: 15px;
            font-size: 0.8em;
            color: #7f8c8d;
        }

        .group-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
            margin-left: 8px;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .character-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .stat-group {
            text-align: center;
            flex: 1;
        }

        .stat-label {
            font-size: 0.8em;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .stat-value {
            font-weight: bold;
            font-size: 1.2em;
            color: #2c3e50;
        }

        .init-bonus {
            font-size: 0.8em;
            color: #7f8c8d;
            margin-left: 5px;
        }

        .controls {
            display: flex;
            gap: 5px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 5px;
        }

        .control-btn {
            padding: 5px 10px;
            font-size: 0.8em;
        }

        .file-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .hidden {
            display: none;
        }

        .combat-controls {
            text-align: center;
            margin: 20px 0;
        }

        .initiative-order {
            font-size: 1.1em;
            margin-bottom: 20px;
            padding: 15px;
            background: #e8f4fd;
            border-radius: 10px;
            border-left: 5px solid #3498db;
        }

        .turn-info {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        #fileInput {
            display: none;
        }

        .hp-bar {
            width: 100%;
            height: 8px;
            background: #ecf0f1;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .hp-fill {
            height: 100%;
            background: #27ae60;
            transition: width 0.3s, background-color 0.3s;
        }

        .hp-fill.low {
            background: #e74c3c;
        }

        .hp-fill.medium {
            background: #f39c12;
        }

        .effects {
            margin: 10px 0;
            min-height: 25px;
        }

        .effect-tag {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7em;
            margin: 2px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .effect-tag.buff {
            background: #27ae60;
            color: white;
        }

        .effect-tag.debuff {
            background: #e74c3c;
            color: white;
        }

        .effect-tag.neutral {
            background: #3498db;
            color: white;
        }

        .effect-tag:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .effect-controls {
            margin: 15px 0;
        }

        .effect-select {
            width: 150px;
            font-size: 0.9em;
            padding: 5px;
            margin-right: 10px;
        }

        .effect-input {
            width: 120px;
            font-size: 0.8em;
            padding: 5px;
            margin-right: 10px;
        }

        .effect-description {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 0.85em;
            line-height: 1.4;
            border-left: 3px solid #3498db;
        }

        .effect-list-container {
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
        }

        .effect-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            margin: 2px 0;
            background: white;
            border-radius: 3px;
            border: 1px solid #ddd;
        }

        .effect-item:hover {
            background: #f8f9fa;
        }

        .custom-hp-controls {
            display: flex;
            gap: 5px;
            justify-content: center;
            align-items: center;
            margin-top: 5px;
        }

        .custom-input {
            width: 60px;
            font-size: 0.8em;
            padding: 3px 6px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 500px;
            max-height: 85vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: black;
        }

        .power-controls {
            display: flex;
            gap: 5px;
            justify-content: center;
            align-items: center;
            margin-top: 5px;
        }

        .power-input {
            width: 40px;
            font-size: 0.8em;
            padding: 3px;
            text-align: center;
        }

        /* Monster database styles */
        .monster-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            border: 2px solid #ecf0f1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }

        .monster-card:hover {
            border-color: #3498db;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .monster-info {
            flex: 1;
        }

        .monster-name {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            cursor: help;
            position: relative;
        }

        .monster-stats-quick {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .monster-actions {
            display: flex;
            gap: 5px;
        }

        /* Tooltip styles */
        .tooltip {
            position: absolute;
            display: none;
            background: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            z-index: 10000;
            max-width: 400px;
            font-size: 0.85em;
            line-height: 1.5;
        }

        .tooltip.show {
            display: block;
        }

        .tooltip h4 {
            margin: 0 0 10px 0;
            color: #3498db;
        }

        .tooltip-section {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .tooltip-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .tooltip a {
            color: #5dade2;
            text-decoration: none;
            border-bottom: 1px dotted #5dade2;
        }

        .tooltip a:hover {
            color: #85c1e9;
            border-bottom: 1px solid #85c1e9;
        }

        /* Statblock panel (collapsible) */
        .statblock-panel {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 3px solid #3498db;
            display: none;
            max-height: 300px;
            overflow-y: auto;
            font-size: 0.85em;
            line-height: 1.6;
        }

        .statblock-panel.show {
            display: block;
        }

        .statblock-panel h5 {
            margin: 10px 0 5px 0;
            color: #3498db;
        }

        .statblock-panel a {
            color: #3498db;
            text-decoration: none;
            border-bottom: 1px dotted #3498db;
        }

        .statblock-panel a:hover {
            color: #2980b9;
            border-bottom: 1px solid #2980b9;
        }

        .statblock-toggle {
            cursor: pointer;
            color: #3498db;
            font-size: 0.9em;
            margin-top: 5px;
            display: inline-block;
        }

        .statblock-toggle:hover {
            text-decoration: underline;
        }

        /* Navigation Bar Styles */
        .nav-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: #2c3e50;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .nav-btn {
            flex: 1;
            padding: 12px 20px;
            background: #34495e;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .nav-btn:hover {
            background: #4a6278;
            transform: translateY(-2px);
        }

        .nav-btn.active {
            background: #3498db;
            box-shadow: 0 4px 8px rgba(52, 152, 219, 0.4);
        }

        /* Page Visibility */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        /* Spell Tracking Styles */
        .spell-page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .character-select {
            padding: 10px 15px;
            border: 2px solid #3498db;
            border-radius: 5px;
            font-size: 1em;
            background: white;
            cursor: pointer;
            min-width: 200px;
        }

        .spell-slots-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .spell-level-group {
            background: white;
            border-radius: 8px;
            padding: 15px;
            border: 2px solid #ecf0f1;
        }

        .spell-level-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            text-align: center;
            font-size: 0.95em;
        }

        .spell-slots {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .spell-slot {
            width: 30px;
            height: 30px;
            border: 2px solid #95a5a6;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            background: #ecf0f1; /* Pr√°zdn√° - dostupn√° */
        }

        .spell-slot.used {
            background: #3498db; /* Pln√° - pou≈æit√° */
            border-color: #3498db;
        }

        .spell-slot:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .custom-features-container {
            margin-top: 20px;
        }

        .feature-item {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            border: 2px solid #ecf0f1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .feature-info {
            flex: 1;
        }

        .feature-name {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .feature-meta {
            font-size: 0.85em;
            color: #7f8c8d;
        }

        .feature-uses {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .use-checkbox {
            width: 25px;
            height: 25px;
            border: 2px solid #95a5a6;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            background: #ecf0f1; /* Pr√°zdn√° - dostupn√° */
        }

        .use-checkbox.used {
            background: #27ae60; /* Pln√° - pou≈æit√° */
            border-color: #27ae60;
        }

        .use-checkbox:hover {
            transform: scale(1.1);
        }

        .rest-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .rest-btn {
            flex: 1;
            padding: 15px;
            font-size: 1.1em;
        }

        .edit-character-btn {
            padding: 12px 20px;
            background: #9b59b6;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .edit-character-btn:hover {
            background: #8e44ad;
        }

        .hit-dice-container {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border: 2px solid #ecf0f1;
        }

        .hit-dice-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .hit-dice-display {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .hit-dice-controls {
            display: flex;
            gap: 5px;
        }

        .hit-die {
            width: 30px;
            height: 30px;
            border: 2px solid #95a5a6;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            background: #ecf0f1; /* Pr√°zdn√° - dostupn√° */
            display: flex;
            align-items: center;
            justify-content: center;
            color: #95a5a6;
            font-weight: bold;
            font-size: 0.9em;
        }

        .hit-die.used {
            background: #e67e22; /* Pln√° - pou≈æit√° */
            border-color: #e67e22;
            color: white;
        }

        .hit-die:hover {
            transform: scale(1.1);
        }

        /* Edit Modal Styles */
        .edit-form-group {
            margin-bottom: 15px;
        }

        .edit-form-group label {
            display: block;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .edit-form-group input,
        .edit-form-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
        }

        .feature-editor {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border: 2px solid #ecf0f1;
        }

        .feature-editor-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .feature-editor-row input,
        .feature-editor-row select {
            flex: 1;
            min-width: 150px;
        }

        .remove-feature-btn {
            padding: 5px 10px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .add-feature-btn {
            width: 100%;
            padding: 10px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        .regain-options {
            display: flex;
            gap: 10px;
            margin-top: 5px;
        }

        .regain-options input {
            width: 80px;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }

        .empty-state-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h1>üêâ DnD Combat Tracker</h1>
            <div style="text-align: right;">
                <div id="viewMode" style="font-size: 0.9em; color: #7f8c8d; margin-bottom: 5px;"></div>
                <div id="connectionStatus" style="font-size: 0.9em;">üî¥ Disconnected</div>
            </div>
        </div>

        <!-- Navigation Bar -->
        <div class="nav-bar">
            <button class="nav-btn active" onclick="switchPage('combat')">‚öîÔ∏è Combat Tracker</button>
            <button class="nav-btn" onclick="switchPage('spells')">‚ú® Spell & Ability Tracking</button>
            <button class="nav-btn" onclick="switchPage('monsters')">üëπ Monster Abilities</button>
        </div>

        <!-- Combat Tracker Page (Main Page) -->
        <div id="combatPage" class="page active">
        <div class="section" id="dataManagementSection">
            <h2>üìÅ Spr√°va dat</h2>
            <div class="file-controls">
                <button onclick="saveData()">üíæ Ulo≈æit data</button>
                <button onclick="saveCombatState()" class="btn-warning" id="saveCombatBtn" style="display:none;">‚öîÔ∏è Ulo≈æit stav boje</button>
                <button onclick="document.getElementById('fileInput').click()">üìÇ Naƒç√≠st data (kumulativnƒõ)</button>
                <input type="file" id="fileInput" accept=".json" onchange="loadData(event)">
                <button onclick="document.getElementById('combatFileInput').click()" class="btn-success">‚öîÔ∏è Naƒç√≠st stav boje</button>
                <input type="file" id="combatFileInput" accept=".json" onchange="loadCombatState(event)" style="display:none;">
                <button onclick="openMonsterDatabase()" class="btn-purple">üìö Datab√°ze monster</button>
                <button onclick="saveAutosave()" class="btn-success" title="Vytvo≈ô√≠ autosave s aktu√°ln√≠m stavem aplikace">üíæ Autosave</button>
                <button onclick="clearAll()" class="btn-danger">üóëÔ∏è Vymazat v≈°e</button>
            </div>
        </div>

        <div class="section" id="addCharacterSection">
            <h2>‚ûï P≈ôidat postavu/monstrum</h2>
            <div class="form-group">
                <input type="text" id="name" placeholder="Jm√©no" required>
                <select id="type">
                    <option value="player">Hr√°ƒç</option>
                    <option value="monster">Monstrum</option>
                </select>
                <input type="number" id="maxHp" placeholder="Max HP" required>
                <input type="number" id="currentHp" placeholder="Aktu√°ln√≠ HP">
                <input type="number" id="ac" placeholder="AC (Armor Class)">
                <input type="number" id="initBonus" placeholder="Bonus na iniciativu">
                <input type="number" id="maxPower" placeholder="Max Moc">
                <input type="number" id="currentPower" placeholder="Aktu√°ln√≠ Moc">
                <button onclick="addCharacter()">P≈ôidat</button>
            </div>
        </div>

        <div class="section">
            <h2>‚öîÔ∏è Boj</h2>
            <div class="combat-controls">
                <button onclick="startCombat()" class="btn-success" id="startBtn">üé≤ Zah√°jit boj</button>
                <button onclick="previousTurn()" class="btn-warning hidden" id="prevBtn">‚¨ÖÔ∏è P≈ôedchoz√≠ tah</button>
                <button onclick="nextTurn()" class="btn-warning hidden" id="nextBtn">‚û°Ô∏è Dal≈°√≠ tah</button>
                <button onclick="endCombat()" class="btn-danger hidden" id="endBtn">üèÅ Ukonƒçit boj</button>
                <button onclick="closeCombat()" class="btn-purple hidden" id="closeBtn">üîí Uzav≈ô√≠t boj</button>
            </div>
            <div id="initiativeOrder" class="initiative-order hidden"></div>
        </div>

        <div class="section">
            <h2>üë• Postavy a monstra</h2>
            <div id="characterList" class="character-list"></div>
        </div>
        </div>
        <!-- End Combat Page -->

        <!-- Spell & Ability Tracking Page -->
        <div id="spellsPage" class="page">
            <div class="section">
                <div class="spell-page-header">
                    <div>
                        <h2>‚ú® Spell & Ability Tracking</h2>
                        <p style="color: #7f8c8d; font-size: 0.9em; margin-top: 5px;">Spravujte spell sloty, abilities a hit dice pro postavy</p>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="spellCharacterSelect" class="character-select" onchange="loadSpellCharacter()">
                            <option value="">-- Vyberte postavu --</option>
                        </select>
                        <button class="edit-character-btn" onclick="openEditSpellCharacter()" id="editSpellCharBtn" style="display:none;">‚öôÔ∏è Upravit</button>
                    </div>
                </div>

                <div id="spellTrackingContent">
                    <div class="empty-state">
                        <div class="empty-state-icon">üé≠</div>
                        <h3>Vyberte postavu</h3>
                        <p>Zvolte postavu ze seznamu v√Ω≈°e pro spr√°vu spell slot≈Ø a abilities</p>
                    </div>
                </div>
            </div>
        </div>
        <!-- End Spell Page -->

        <!-- Monster Abilities Page -->
        <div id="monstersPage" class="page">
            <div class="section">
                <div class="spell-page-header">
                    <div>
                        <h2>üëπ Monster Abilities & Spellcasting</h2>
                        <p style="color: #7f8c8d; font-size: 0.9em; margin-top: 5px;">Spravujte spell sloty, abilities a legendary actions pro monstra</p>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="monsterCharacterSelect" class="character-select" onchange="loadMonsterCharacter()">
                            <option value="">-- Vyberte monstrum --</option>
                        </select>
                    </div>
                </div>

                <div id="monsterAbilityContent">
                    <div class="empty-state">
                        <div class="empty-state-icon">üëπ</div>
                        <h3>Vyberte monstrum</h3>
                        <p>Zvolte monstrum ze seznamu v√Ω≈°e pro spr√°vu abilities a spellcastingu</p>
                    </div>
                </div>
            </div>
        </div>
        <!-- End Monster Page -->

    </div>
    <!-- End Container -->

    <!-- Modal pro datab√°zi monster -->
    <div id="monsterDatabaseModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <span class="close" onclick="closeMonsterDatabase()">&times;</span>
            <h3>üìö Datab√°ze monster</h3>

            <div class="file-controls" style="margin-bottom: 15px;">
                <button onclick="openAddMonsterModal()" class="btn-success">‚ûï P≈ôidat monstrum</button>
                <button onclick="exportMonsterDatabase()" class="btn-warning">üíæ Exportovat datab√°zi</button>
                <button onclick="document.getElementById('monsterDbFileInput').click()">üìÇ Importovat datab√°zi</button>
                <input type="file" id="monsterDbFileInput" accept=".json" onchange="importMonsterDatabase(event)" style="display:none;">
                <button onclick="clearMonsterDatabase()" class="btn-danger">üóëÔ∏è Vyƒçistit datab√°zi</button>
            </div>

            <div id="monsterList" style="max-height: 500px; overflow-y: auto;"></div>
        </div>
    </div>

    <!-- Modal pro p≈ôid√°n√≠/import monstra -->
    <div id="addMonsterModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <span class="close" onclick="closeAddMonsterModal()">&times;</span>
            <h3>‚ûï P≈ôidat monstrum do datab√°ze</h3>

            <div style="margin: 15px 0;">
                <h4>Import z Notion linku:</h4>
                <input type="text" id="notionLinkInput" placeholder="https://www.notion.so/..." style="width: 100%; padding: 10px; margin-bottom: 10px;">
                <button onclick="importFromNotion()" class="btn-success">Naƒç√≠st z Notion</button>
            </div>

            <div style="margin: 15px 0;">
                <h4>Nebo vlo≈æte statblock (Ctrl+V):</h4>
                <textarea id="statblockInput" placeholder="Vlo≈æte cel√Ω statblock..." style="width: 100%; height: 200px; padding: 10px; font-family: monospace; font-size: 0.9em;"></textarea>
                <button onclick="parseStatblock()" class="btn-success">Parsovat statblock</button>
            </div>

            <div id="monsterPreview" style="display: none; margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px;">
                <h4>N√°hled:</h4>
                <div id="monsterPreviewContent"></div>
                <button onclick="saveMonsterToDatabase()" class="btn-success" style="margin-top: 10px;">üíæ Ulo≈æit do datab√°ze</button>
            </div>
        </div>
    </div>

    <!-- Modal pro efekty -->
    <div id="effectModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeEffectModal()">&times;</span>
            <h3>üé≠ Efekty pro <span id="effectCharacterName"></span></h3>
            <div id="effectList"></div>
            <div class="effect-controls">
                <h4>P≈ôidat efekt:</h4>
                <div style="margin: 10px 0;">
                    <select id="effectSelect" class="effect-select">
                        <option value="">-- Vyberte efekt --</option>
                        <optgroup label="üî¥ Debuffs">
                            <option value="Blinded">Blinded</option>
                            <option value="Charmed">Charmed</option>
                            <option value="Deafened">Deafened</option>
                            <option value="Exhaustion">Exhaustion</option>
                            <option value="Frightened">Frightened</option>
                            <option value="Grappled">Grappled</option>
                            <option value="Incapacitated">Incapacitated</option>
                            <option value="Paralyzed">Paralyzed</option>
                            <option value="Petrified">Petrified</option>
                            <option value="Poisoned">Poisoned</option>
                            <option value="Prone">Prone</option>
                            <option value="Restrained">Restrained</option>
                            <option value="Stunned">Stunned</option>
                            <option value="Unconscious">Unconscious</option>
                            <option value="Defenseless">Defenseless</option>
                            <option value="Impaired">Impaired</option>
                            <option value="Distracted">Distracted</option>
                            <option value="Hexblade_Curse">Hexblade's Curse</option>
                            <option value="Moonlit">Moonlit</option>
                            <option value="Confused">Confused</option>
                            <option value="Divine_Ire">Divine Ire</option>
                            <option value="Divine_Ire_Cyric">Divine Ire (Cyric)</option>
                        </optgroup>
                        <optgroup label="üü¢ Buffs">
                            <option value="Hasted">Hasted</option>
                            <option value="Inspired">Inspired</option>
                            <option value="Invisible">Invisible</option>
                            <option value="Raging">Raging</option>
                            <option value="Dodging">Dodging</option>
                            <option value="Heroic_Inspiration">Heroic Inspiration</option>
                            <option value="Spirit_Shroud">Spirit Shroud</option>
                            <option value="Tensor_Transformation">Tensor Transformation</option>
                            <option value="Retaliation_Aura">Retaliation Aura</option>
                            <option value="Foresight">Foresight</option>
                            <option value="Elder_Champion">Elder Champion</option>
                            <option value="Celestial_Revelation">Celestial Revelation</option>
                            <option value="Power_of_Mercy">Power of Mercy</option>
                            <option value="Sacred_Divine_Sense">Sacred Divine Sense</option>
                            <option value="Protective_Spirit">Protective Spirit</option>
                            <option value="Emissary_of_Redemtion">Emissary of Redemtion</option>
                            <option value="Rythm_of_War">Rythm of War</option>
                        </optgroup>
                        <optgroup label="üîµ Neutr√°ln√≠">
                            <option value="Concentrating">Concentrating</option>
                            <option value="Marked">Marked</option>
                            <option value="Irredeemable">Irredeemable</option>
                            <option value="Not_Harmonized">Not Harmonized</option>
                        </optgroup>
                    </select>
                    <button onclick="addEffect()" class="btn-success">P≈ôidat vybran√Ω</button>
                </div>
                <div style="margin: 10px 0;">
                    <input type="text" id="newEffect" class="effect-input" placeholder="Vlastn√≠ efekt">
                    <button onclick="addEffect()" class="btn-success">P≈ôidat vlastn√≠</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal pro editaci monstra -->
    <div id="editMonsterModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeEditMonsterModal()">&times;</span>
            <h3>‚úèÔ∏è Editovat monstrum</h3>

            <div style="margin: 20px 0;">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;"><strong>Jm√©no:</strong></label>
                    <input type="text" id="editMonsterName" style="width: 100%; padding: 8px;">
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px;"><strong>AC:</strong></label>
                        <input type="number" id="editMonsterAC" style="width: 100%; padding: 8px;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px;"><strong>HP:</strong></label>
                        <input type="number" id="editMonsterHP" style="width: 100%; padding: 8px;">
                    </div>
                </div>

                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;"><strong>Speed:</strong></label>
                    <input type="text" id="editMonsterSpeed" style="width: 100%; padding: 8px;" placeholder="30 ft.">
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div>
                        <label style="display: block; margin-bottom: 5px;"><strong>Type:</strong></label>
                        <input type="text" id="editMonsterType" style="width: 100%; padding: 8px;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px;"><strong>Size:</strong></label>
                        <input type="text" id="editMonsterSize" style="width: 100%; padding: 8px;">
                    </div>
                </div>

                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #3498db;">‚ö° Power Syst√©m</h4>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px;"><strong>N√°zev Power:</strong></label>
                        <input type="text" id="editMonsterPowerName" style="width: 100%; padding: 8px;" placeholder="Power (nebo Grit, Fortitude, atd.)">
                        <small style="color: #7f8c8d; display: block; margin-top: 3px;">Vlastn√≠ n√°zev pro power resource tohoto monstra</small>
                    </div>

                    <div>
                        <label style="display: block; margin-bottom: 5px;"><strong>Maxim√°ln√≠ Power:</strong></label>
                        <input type="number" id="editMonsterMaxPower" style="width: 100%; padding: 8px;" placeholder="0">
                        <small style="color: #7f8c8d; display: block; margin-top: 3px;">Nechte 0 pokud monstrum nepou≈æ√≠v√° power syst√©m</small>
                    </div>
                </div>

                <button onclick="saveEditedMonster()" class="btn-success" style="width: 100%; padding: 12px; font-size: 1.1em;">üíæ Ulo≈æit zmƒõny</button>
            </div>
        </div>
    </div>

    <!-- Modal pro editaci spell charakteru -->
    <div id="editSpellCharacterModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <span class="close" onclick="closeEditSpellCharacter()">&times;</span>
            <h3>‚öôÔ∏è Upravit <span id="editSpellCharName"></span></h3>

            <div class="edit-form-group">
                <label>‚ú® Spellcaster Level (0-30, vƒçetnƒõ Epic level≈Ø):</label>
                <input type="number" id="spellcasterLevelInput" min="0" max="30" value="0">
                <small style="color: #7f8c8d; display: block; margin-top: 3px;">Levely 1-20 = standardn√≠ D&D 5e, levely 21-30 = Epic spell sloty</small>
            </div>

            <div class="edit-form-group">
                <label>‚ù§Ô∏è Hit Dice:</label>
                <input type="number" id="hitDiceMaxInput" min="0" value="0">
                <small style="color: #7f8c8d; display: block; margin-top: 3px;">Maxim√°ln√≠ poƒçet hit dice pro postavu</small>
            </div>

            <div class="edit-form-group">
                <label>üéØ Custom Features & Abilities:</label>
                <div id="customFeaturesEditor"></div>
                <button class="add-feature-btn" onclick="addCustomFeatureEditor()">‚ûï P≈ôidat Feature</button>
            </div>

            <button onclick="saveSpellCharacter()" class="btn-success" style="width: 100%; padding: 12px; font-size: 1.1em; margin-top: 20px;">üíæ Ulo≈æit zmƒõny</button>
        </div>
    </div>

    <!-- File Name Modal -->
    <div id="fileNameModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <span class="close" onclick="closeFileNameModal()">&times;</span>
            <h3 id="fileNameModalTitle">üíæ Pojmenovat soubor</h3>

            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 5px;"><strong>N√°zev souboru:</strong></label>
                <input type="text" id="fileNameInput" style="width: 100%; padding: 10px; font-size: 1em;" placeholder="n√°zev-souboru">
                <small style="color: #7f8c8d; display: block; margin-top: 5px;">P≈ô√≠pona .json bude p≈ôid√°na automaticky</small>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button onclick="closeFileNameModal()" class="btn-secondary" style="width: 100%; padding: 10px;">Zru≈°it</button>
                <button onclick="confirmFileName()" class="btn-success" style="width: 100%; padding: 10px;">üíæ Ulo≈æit</button>
            </div>
        </div>
    </div>

    <script>
        // ===== MODE DETECTION & WEBSOCKET SETUP =====
        const urlParams = new URLSearchParams(window.location.search);
        const viewMode = urlParams.get('mode') || 'dm'; // 'dm' or 'player'
        const isDM = viewMode === 'dm';
        const isPlayer = viewMode === 'player';

        // Update title based on mode
        document.title = isDM ? 'DnD Tracker - DM' : 'DnD Tracker - Player View';

        // WebSocket connection
        let socket = null;
        let isConnected = false;
        let isSyncing = false; // Prevent sync loop

        function initializeWebSocket() {
            socket = io();

            socket.on('connect', () => {
                console.log('Connected to server');
                isConnected = true;
                updateConnectionStatus(true);

                // Register client mode with server
                socket.emit('register-mode', viewMode);
                console.log(`Registered as ${viewMode} mode`);
            });

            socket.on('disconnect', () => {
                console.log('Disconnected from server');
                isConnected = false;
                updateConnectionStatus(false);
            });

            // Receive full state sync from server
            socket.on('state-sync', (serverState) => {
                isSyncing = true; // Set flag to prevent re-sync
                // Ensure backward compatibility for revealedToPlayers flag
                characters = (serverState.characters || []).map(char => ({
                    ...char,
                    revealedToPlayers: char.revealedToPlayers !== undefined ? char.revealedToPlayers : (char.type === 'player')
                }));
                combatState = serverState.combatState || combatState;
                monsterDatabase = serverState.monsterDatabase || [];

                // Pou≈æ√≠t glob√°ln√≠ historii ze serveru
                historyStack = serverState.historyStack || [];
                redoStack = serverState.redoStack || [];

                renderCharacters();
                renderMonsterList();
                updateInitiativeDisplay();
                isSyncing = false; // Clear flag
            });

            // Receive individual character updates
            socket.on('character-updated', (characterData) => {
                isSyncing = true;
                const index = characters.findIndex(c => c.id === characterData.id);
                if (index !== -1) {
                    // Ensure backward compatibility
                    characters[index] = {
                        ...characterData,
                        revealedToPlayers: characterData.revealedToPlayers !== undefined ? characterData.revealedToPlayers : (characterData.type === 'player')
                    };
                    renderCharacters();
                }
                isSyncing = false;
            });

            // Receive combat state updates
            socket.on('combat-updated', (combatData) => {
                isSyncing = true;
                combatState = combatData;
                updateInitiativeDisplay();
                renderCharacters();
                isSyncing = false;
            });
        }

        // Send state updates to server
        function syncToServer() {
            if (isSyncing) return; // Don't sync if we're receiving updates
            if (socket && isConnected) {
                socket.emit('update-state', {
                    characters,
                    combatState,
                    monsterDatabase,
                    historyStack,
                    redoStack
                });
            }
        }

        function updateConnectionStatus(connected) {
            // Show connection status indicator
            const indicator = document.getElementById('connectionStatus');
            if (indicator) {
                indicator.textContent = connected ? 'üü¢ Connected' : 'üî¥ Disconnected';
                indicator.style.color = connected ? '#27ae60' : '#e74c3c';
            }
        }

        let characters = [];
        let combatState = {
            active: false,
            currentTurn: 0,
            round: 1,
            playedThisRound: []
        };
        let currentEffectCharacterId = null;
        let autoSaveInterval = null;
        let historyStack = [];
        let redoStack = [];
        const MAX_HISTORY = 20;
        let draggedCharacterIndex = null;
        let monsterDatabase = [];
        let currentMonsterForStatblock = null;
        let currentEditingMonsterId = null;

        // ===== MONSTER DATABASE FUNCTIONS =====

        // LocalStorage pro datab√°zi monster
        function saveMonsterDatabaseToStorage() {
            try {
                localStorage.setItem('dnd-monster-database', JSON.stringify(monsterDatabase));
            } catch (error) {
                console.error('Error saving monster database:', error);
            }
        }

        function loadMonsterDatabaseFromStorage() {
            try {
                const saved = localStorage.getItem('dnd-monster-database');
                if (saved) {
                    monsterDatabase = JSON.parse(saved);
                }
            } catch (error) {
                console.error('Error loading monster database:', error);
            }
        }

        // Modal funkce
        function openMonsterDatabase() {
            document.getElementById('monsterDatabaseModal').style.display = 'block';
            renderMonsterList();
        }

        function closeMonsterDatabase() {
            document.getElementById('monsterDatabaseModal').style.display = 'none';
        }

        function openAddMonsterModal() {
            document.getElementById('addMonsterModal').style.display = 'block';
            document.getElementById('statblockInput').value = '';
            document.getElementById('notionLinkInput').value = '';
            document.getElementById('monsterPreview').style.display = 'none';
        }

        function closeAddMonsterModal() {
            document.getElementById('addMonsterModal').style.display = 'none';
            currentMonsterForStatblock = null;
        }

        // Parser pro statblock
        function parseStatblock() {
            const input = document.getElementById('statblockInput').value;
            if (!input.trim()) {
                alert('Vlo≈æte pros√≠m statblock!');
                return;
            }

            const monster = parseStatblockText(input);
            if (monster) {
                currentMonsterForStatblock = monster;
                showMonsterPreview(monster);
            } else {
                alert('Nepoda≈ôilo se parsovat statblock. Zkontrolujte form√°t.');
            }
        }

        function parseStatblockText(text) {
            try {
                const monster = {
                    name: '',
                    ac: 10,
                    hp: 10,
                    speed: '30 ft.',
                    initBonus: 0,
                    stats: { str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 },
                    cr: '0',
                    type: 'unknown',
                    size: 'medium',
                    savingThrows: '',
                    resistances: '',
                    immunities: '',
                    proficiency: '',
                    rawStatblock: text,
                    defensiveTraits: [],
                    traits: [],
                    actions: [],
                    bonusActions: [],
                    reactions: [],
                    legendaryActions: [],
                    mythicActions: [],
                    lairActions: []
                };

                // Parse n√°zev (prvn√≠ ≈ô√°dek nebo z **Armor Class:**)
                const firstLine = text.split('\n')[0].trim();
                if (firstLine && !firstLine.includes(':')) {
                    monster.name = firstLine.replace(/^#+ /, '');
                }

                // Parse AC
                const acMatch = text.match(/\*\*Armor Class:\*\*\s*(\d+)/i);
                if (acMatch) monster.ac = parseInt(acMatch[1]);

                // Parse HP
                const hpMatch = text.match(/\*\*Hit Points:\*\*\s*(\d+)/i);
                if (hpMatch) monster.hp = parseInt(hpMatch[1]);

                // Parse Speed
                const speedMatch = text.match(/\*\*Speed:\*\*\s*([^\n]+)/i);
                if (speedMatch) monster.speed = speedMatch[1].trim();

                // Parse Stats z tabulky
                const statsMatch = text.match(/\|\s*(\d+)\s*\([+-]?\d+\)\s*\|\s*(\d+)\s*\([+-]?\d+\)\s*\|\s*(\d+)\s*\([+-]?\d+\)\s*\|\s*(\d+)\s*\([+-]?\d+\)\s*\|\s*(\d+)\s*\([+-]?\d+\)\s*\|\s*(\d+)\s*\([+-]?\d+\)\s*\|/);
                if (statsMatch) {
                    monster.stats.str = parseInt(statsMatch[1]);
                    monster.stats.dex = parseInt(statsMatch[2]);
                    monster.stats.con = parseInt(statsMatch[3]);
                    monster.stats.int = parseInt(statsMatch[4]);
                    monster.stats.wis = parseInt(statsMatch[5]);
                    monster.stats.cha = parseInt(statsMatch[6]);

                    // Vypoƒç√≠tej initiative bonus z Dexterity
                    monster.initBonus = Math.floor((monster.stats.dex - 10) / 2);
                }

                // Parse Saving Throws
                const savingThrowsMatch = text.match(/\*\*Saving Throws:\*\*\s*([^\n]+)/i);
                if (savingThrowsMatch) {
                    monster.savingThrows = savingThrowsMatch[1].trim().replace(/,\s*$/, ''); // Odstra≈à trailing comma
                }

                // Parse Damage Resistances
                const resistancesMatch = text.match(/\*\*Damage Resistances:\*\*\s*([^\n]+)/i);
                if (resistancesMatch) {
                    monster.resistances = resistancesMatch[1].trim();
                }

                // Parse Immunities
                const immunitiesMatch = text.match(/\*\*Immunities:\*\*\s*([^\n]+)/i);
                if (immunitiesMatch) {
                    // Odstra≈à Notion linky jako [Frightened](url)
                    monster.immunities = immunitiesMatch[1].trim().replace(/\[([^\]]+)\]\([^)]+\)/g, '$1');
                }

                // Parse Proficiency
                const proficiencyMatch = text.match(/\*\*Proficiency:\*\*\s*([+-]?\d+)/i);
                if (proficiencyMatch) {
                    monster.proficiency = proficiencyMatch[1];
                }

                // Parse Challenge points m√≠sto CR
                const challengeMatch = text.match(/\*\*Challenge\*\*\s*[\d\/]+\s*\((\d+)\s*points?\)/i);
                if (challengeMatch) {
                    monster.cr = challengeMatch[1] + ' point' + (challengeMatch[1] === '1' ? '' : 's');
                } else {
                    // Fallback na p≈Øvodn√≠ CR, pokud nejsou body
                    const crMatch = text.match(/\*\*Challenge\*\*\s*([\d\/]+)/i);
                    if (crMatch) monster.cr = crMatch[1];
                }

                // Parse Type
                const typeMatch = text.match(/\*\*Type:\*\*\s*(\w+)/i);
                if (typeMatch) monster.type = typeMatch[1].toLowerCase();

                // Parse Size
                const sizeMatch = text.match(/\*\*Size:\*\*\s*(\w+)/i);
                if (sizeMatch) monster.size = sizeMatch[1].toLowerCase();

                // Helper funkce pro parsov√°n√≠ sekc√≠
                const parseSection = (sectionName) => {
                    // Najdi sekci a extrahuj obsah a≈æ do dal≈°√≠ sekce nebo konce
                    const sectionRegex = new RegExp(`# ${sectionName}([\\s\\S]*?)(?=# [A-Z]|---|$)`, 'i');
                    const sectionMatch = text.match(sectionRegex);
                    if (sectionMatch) {
                        // Rozdƒõl podle patternu, kde entry zaƒç√≠n√° **N√°zev** na zaƒç√°tku ≈ô√°dku
                        const blocks = sectionMatch[1].split(/(?=^\*\*[A-Z])/m).filter(b => b.trim());
                        return blocks.map(b => b.trim());
                    }
                    return [];
                };

                // Parse Defensive Traits
                monster.defensiveTraits = parseSection('Defensive Traits');

                // Parse Regular Traits (tak√© zachovej zpƒõtnou kompatibilitu s "Defense Traits")
                monster.traits = parseSection('Regular Traits');
                if (monster.traits.length === 0) {
                    monster.traits = parseSection('Defense Traits');
                }

                // Parse Actions
                monster.actions = parseSection('Actions');

                // Parse Bonus Actions
                monster.bonusActions = parseSection('Bonus Actions');

                // Parse Reactions
                monster.reactions = parseSection('Reactions');

                // Parse Legendary Actions
                monster.legendaryActions = parseSection('Legendary Actions');

                // Parse Mythic Actions
                monster.mythicActions = parseSection('Mythic Actions');

                // Parse Lair Actions
                monster.lairActions = parseSection('Lair Actions');

                // ===== PARSE MONSTER ABILITIES =====
                monster.monsterAbilities = {
                    enabled: false,
                    spellcastingType: 'none',
                    spellcastingLevel: 0,
                    spellSlots: {},
                    perDaySpells: [],
                    legendaryActions: {
                        enabled: false,
                        max: 3,
                        used: 0
                    },
                    customFeatures: []
                };

                console.log('üîç Parser Debug - Starting Monster Abilities parsing');

                // Detect Spellcasting from actions
                const spellcastingBlock = monster.actions.find(action =>
                    action.toLowerCase().includes('spellcasting') ||
                    action.toLowerCase().includes('innate spellcasting')
                );

                if (spellcastingBlock) {
                    console.log('‚úÖ Found spellcasting block:', spellcastingBlock.substring(0, 100));
                    monster.monsterAbilities.enabled = true;

                    // Check for level-based spellcasting
                    const levelMatch = spellcastingBlock.match(/(\d+)(?:th|st|nd|rd)[-\s]level\s+spellcaster/i);
                    if (levelMatch) {
                        console.log('‚úÖ Level-based spellcasting detected, level:', levelMatch[1]);
                        monster.monsterAbilities.spellcastingType = 'level-based';
                        monster.monsterAbilities.spellcastingLevel = parseInt(levelMatch[1]);

                        // Parse custom slot counts
                        const customSlotsRegex = /(\d+)(?:st|nd|rd|th)\s+level\s+\((\d+)\s+slot/gi;
                        let match;
                        while ((match = customSlotsRegex.exec(spellcastingBlock)) !== null) {
                            const spellLevel = parseInt(match[1]);
                            const slotCount = parseInt(match[2]);
                            console.log(`  Slot: Level ${spellLevel} = ${slotCount} slots`);
                            monster.monsterAbilities.spellSlots[spellLevel] = {
                                max: slotCount,
                                used: 0
                            };
                        }
                    }
                    // Check for per-day spellcasting
                    else if (spellcastingBlock.match(/at will|\/day/i)) {
                        console.log('‚úÖ Per-day spellcasting detected');
                        monster.monsterAbilities.spellcastingType = 'per-day';

                        // Parse per-day spells - improved regex for multiline
                        // Match: "At Will:", "3/Day:", "1/Day:" followed by spell list until next usage line or end
                        const lines = spellcastingBlock.split('\n');
                        let currentUses = null;
                        let currentSpells = [];

                        for (let line of lines) {
                            // Check if line starts with usage pattern
                            const usageMatch = line.match(/^((?:(\d+)\/[Dd]ay)|(?:[Aa]t [Ww]ill))[^:]*:\s*(.*)$/);
                            if (usageMatch) {
                                // Save previous group
                                if (currentUses !== null && currentSpells.length > 0) {
                                    currentSpells.forEach(spellName => {
                                        console.log(`  Adding spell: ${spellName} (${currentUses === 999 ? 'At Will' : currentUses + '/Day'})`);
                                        monster.monsterAbilities.perDaySpells.push({
                                            name: spellName,
                                            maxUses: currentUses,
                                            used: 0
                                        });
                                    });
                                }

                                // Start new group
                                currentUses = usageMatch[2] ? parseInt(usageMatch[2]) : 999; // At will = 999
                                currentSpells = [];

                                // Parse spells on same line
                                const spellsOnLine = usageMatch[3];
                                if (spellsOnLine && spellsOnLine.trim()) {
                                    const spells = spellsOnLine
                                        .split(',')
                                        .map(s => s.replace(/\[([^\]]+)\]\([^)]+\)/g, '$1').trim())
                                        .filter(s => s.length > 0 && !s.match(/^counterspells?$/i)); // Skip "Counterspells:" label

                                    currentSpells.push(...spells);
                                }
                            } else if (currentUses !== null && line.trim()) {
                                // Continue parsing spells from continuation lines
                                const spells = line
                                    .split(',')
                                    .map(s => s.replace(/\[([^\]]+)\]\([^)]+\)/g, '$1').trim())
                                    .filter(s => s.length > 0 && !s.match(/^[\-‚Ä¢]\s*$/) && !s.match(/^counterspells?$/i));

                                if (spells.length > 0) {
                                    currentSpells.push(...spells);
                                }
                            }
                        }

                        // Save last group
                        if (currentUses !== null && currentSpells.length > 0) {
                            currentSpells.forEach(spellName => {
                                console.log(`  Adding spell: ${spellName} (${currentUses === 999 ? 'At Will' : currentUses + '/Day'})`);
                                monster.monsterAbilities.perDaySpells.push({
                                    name: spellName,
                                    maxUses: currentUses,
                                    used: 0
                                });
                            });
                        }
                    }
                }

                // Detect Legendary Actions
                if (monster.legendaryActions && monster.legendaryActions.length > 0) {
                    console.log('‚úÖ Legendary Actions detected');
                    monster.monsterAbilities.enabled = true;
                    monster.monsterAbilities.legendaryActions.enabled = true;

                    const laText = monster.legendaryActions[0] || '';
                    const laCountMatch = laText.match(/can take (\d+) legendary action/i);
                    if (laCountMatch) {
                        monster.monsterAbilities.legendaryActions.max = parseInt(laCountMatch[1]);
                        console.log(`  Count: ${monster.monsterAbilities.legendaryActions.max}`);
                    }
                }

                // Parse custom features - improved to handle multiline traits
                const allTraits = [
                    ...monster.defensiveTraits,
                    ...monster.traits,
                    ...monster.bonusActions
                ];

                console.log(`üîç Checking ${allTraits.length} traits for custom features`);
                allTraits.forEach((trait, idx) => {
                    // Match pattern at start: **Name (usage).**
                    const featureMatch = trait.match(/^\*\*([^(]+?)\s*\(([^)]+)\)\.\*\*/);
                    if (featureMatch) {
                        const featureName = featureMatch[1].trim();
                        const usageInfo = featureMatch[2].trim();
                        console.log(`  Checking trait ${idx}: "${featureName}" with usage "${usageInfo}"`);

                        let maxUses = 0;
                        let restType = 'none';

                        if (usageInfo.match(/(\d+)\/[Ll]ong\s*[Rr]est/i)) {
                            const match = usageInfo.match(/(\d+)\/[Ll]ong\s*[Rr]est/i);
                            maxUses = parseInt(match[1]);
                            restType = 'long';
                            console.log(`    ‚úÖ Matched: ${maxUses}/Long Rest`);
                        } else if (usageInfo.match(/(\d+)\/[Ss]hort\s*[Rr]est/i)) {
                            const match = usageInfo.match(/(\d+)\/[Ss]hort\s*[Rr]est/i);
                            maxUses = parseInt(match[1]);
                            restType = 'short';
                            console.log(`    ‚úÖ Matched: ${maxUses}/Short Rest`);
                        } else if (usageInfo.match(/(\d+)\/[Dd]ay/i)) {
                            const match = usageInfo.match(/(\d+)\/[Dd]ay/i);
                            maxUses = parseInt(match[1]);
                            restType = 'day';
                            console.log(`    ‚úÖ Matched: ${maxUses}/Day`);
                        } else if (usageInfo.match(/[Rr]echarge\s*(\d+)/i)) {
                            maxUses = 1;
                            restType = 'recharge';
                            console.log(`    ‚úÖ Matched: Recharge`);
                        } else if (usageInfo.match(/1\/[Rr]est/i)) {
                            maxUses = 1;
                            restType = 'long';
                            console.log(`    ‚úÖ Matched: 1/Rest`);
                        }

                        if (maxUses > 0) {
                            monster.monsterAbilities.enabled = true;
                            monster.monsterAbilities.customFeatures.push({
                                name: featureName,
                                maxUses: maxUses,
                                used: 0,
                                restType: restType
                            });
                            console.log(`    ‚ûï Added custom feature: ${featureName} (${maxUses} uses)`);
                        }
                    }
                });

                console.log('üîç Parser Debug - Monster Abilities Summary:');
                console.log(`  Enabled: ${monster.monsterAbilities.enabled}`);
                console.log(`  Spellcasting Type: ${monster.monsterAbilities.spellcastingType}`);
                console.log(`  Per-Day Spells: ${monster.monsterAbilities.perDaySpells.length}`);
                console.log(`  Custom Features: ${monster.monsterAbilities.customFeatures.length}`);
                console.log(`  Legendary Actions: ${monster.monsterAbilities.legendaryActions.enabled}`);

                // Pokud nem√°me jm√©no, zkus naj√≠t prvn√≠ nadpis
                if (!monster.name) {
                    const nameMatch = text.match(/^#+ (.+)$/m);
                    if (nameMatch) monster.name = nameMatch[1].trim();
                }

                return monster;
            } catch (error) {
                console.error('Parse error:', error);
                return null;
            }
        }

        function showMonsterPreview(monster) {
            const preview = document.getElementById('monsterPreviewContent');

            // Form√°tuj staty s bonusy
            const statStr = (stat) => {
                const bonus = Math.floor((stat - 10) / 2);
                return `${stat} (${bonus >= 0 ? '+' : ''}${bonus})`;
            };

            preview.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <p><strong>Jm√©no:</strong> ${monster.name || 'Nezn√°m√©'}</p>
                    <p><strong>AC:</strong> ${monster.ac} | <strong>HP:</strong> ${monster.hp} | <strong>Speed:</strong> ${monster.speed}</p>
                    <p><strong>Type:</strong> ${monster.type} | <strong>Size:</strong> ${monster.size} | <strong>Challenge:</strong> ${monster.cr}</p>
                </div>

                <div style="margin-bottom: 15px; font-size: 0.9em;">
                    <table style="width: 100%; border-collapse: collapse; text-align: center;">
                        <tr style="background: #ecf0f1;">
                            <th style="padding: 5px;">STR</th>
                            <th style="padding: 5px;">DEX</th>
                            <th style="padding: 5px;">CON</th>
                            <th style="padding: 5px;">INT</th>
                            <th style="padding: 5px;">WIS</th>
                            <th style="padding: 5px;">CHA</th>
                        </tr>
                        <tr>
                            <td style="padding: 5px;">${statStr(monster.stats.str)}</td>
                            <td style="padding: 5px;">${statStr(monster.stats.dex)}</td>
                            <td style="padding: 5px;">${statStr(monster.stats.con)}</td>
                            <td style="padding: 5px;">${statStr(monster.stats.int)}</td>
                            <td style="padding: 5px;">${statStr(monster.stats.wis)}</td>
                            <td style="padding: 5px;">${statStr(monster.stats.cha)}</td>
                        </tr>
                    </table>
                </div>

                ${monster.savingThrows ? `<p><strong>Saving Throws:</strong> ${monster.savingThrows}</p>` : ''}
                ${monster.resistances ? `<p><strong>Damage Resistances:</strong> ${monster.resistances}</p>` : ''}
                ${monster.immunities ? `<p><strong>Immunities:</strong> ${monster.immunities}</p>` : ''}
                ${monster.proficiency ? `<p><strong>Proficiency:</strong> ${monster.proficiency}</p>` : ''}

                <div style="margin-top: 10px;">
                    ${monster.defensiveTraits && monster.defensiveTraits.length > 0 ? `<p><strong>Defensive Traits:</strong> ${monster.defensiveTraits.length}</p>` : ''}
                    ${monster.traits && monster.traits.length > 0 ? `<p><strong>Traits:</strong> ${monster.traits.length}</p>` : ''}
                    ${monster.actions && monster.actions.length > 0 ? `<p><strong>Actions:</strong> ${monster.actions.length}</p>` : ''}
                    ${monster.bonusActions && monster.bonusActions.length > 0 ? `<p><strong>Bonus Actions:</strong> ${monster.bonusActions.length}</p>` : ''}
                    ${monster.reactions && monster.reactions.length > 0 ? `<p><strong>Reactions:</strong> ${monster.reactions.length}</p>` : ''}
                    ${monster.legendaryActions && monster.legendaryActions.length > 0 ? `<p><strong>Legendary Actions:</strong> ${monster.legendaryActions.length}</p>` : ''}
                    ${monster.mythicActions && monster.mythicActions.length > 0 ? `<p><strong>Mythic Actions:</strong> ${monster.mythicActions.length}</p>` : ''}
                    ${monster.lairActions && monster.lairActions.length > 0 ? `<p><strong>Lair Actions:</strong> ${monster.lairActions.length}</p>` : ''}
                </div>
            `;
            document.getElementById('monsterPreview').style.display = 'block';
        }

        function saveMonsterToDatabase() {
            if (!currentMonsterForStatblock) return;

            if (!currentMonsterForStatblock.name) {
                alert('Monstrum mus√≠ m√≠t jm√©no!');
                return;
            }

            monsterDatabase.push({
                ...currentMonsterForStatblock,
                id: Date.now() + Math.random()
            });

            saveMonsterDatabaseToStorage();
            closeAddMonsterModal();
            renderMonsterList();
            alert(`${currentMonsterForStatblock.name} p≈ôid√°n do datab√°ze!`);
        }

        // ===== DYNAMIC NAME NUMBERING =====
        // Helper funkce pro z√≠sk√°n√≠ unik√°tn√≠ho jm√©na s inteligentn√≠m ƒç√≠slov√°n√≠m
        function getUniqueName(baseName) {
            // Escape speci√°ln√≠ regex znaky v n√°zvu
            const escapedName = baseName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            // Najdi v≈°echny postavy se stejn√Ωm z√°kladn√≠m jm√©nem (s ƒç√≠slem nebo bez)
            const regex = new RegExp(`^${escapedName}(\\s+\\d+)?$`, 'i');
            const similarChars = characters.filter(c => regex.test(c.name));

            // Pokud ≈æ√°dn√° podobn√° neexistuje, vra≈• z√°kladn√≠ jm√©no bez ƒç√≠sla
            if (similarChars.length === 0) {
                return baseName;
            }

            // Pokud existuje postava se stejn√Ωm jm√©nem BEZ ƒç√≠sla, p≈ôejmenuj ji na "n√°zev 1"
            const unnumbered = similarChars.find(c => c.name === baseName);
            if (unnumbered) {
                unnumbered.name = `${baseName} 1`;
            }

            // Najdi nejvy≈°≈°√≠ pou≈æit√© ƒç√≠slo
            const numbers = similarChars.map(c => {
                const match = c.name.match(/\s+(\d+)$/);
                return match ? parseInt(match[1]) : 0;
            });

            const maxNum = Math.max(...numbers, 1);  // Minim√°lnƒõ 1
            return `${baseName} ${maxNum + 1}`;
        }

        // Render seznam monster v datab√°zi
        function renderMonsterList() {
            const listDiv = document.getElementById('monsterList');

            if (monsterDatabase.length === 0) {
                listDiv.innerHTML = '<p style="color: #7f8c8d; text-align: center; padding: 40px;">Datab√°ze je pr√°zdn√°. P≈ôidejte prvn√≠ monstrum!</p>';
                return;
            }

            listDiv.innerHTML = monsterDatabase.map(monster => `
                <div class="monster-card">
                    <div class="monster-info">
                        <div class="monster-name"
                             onmouseenter="showMonsterTooltip(event, ${monster.id})"
                             onmouseleave="hideMonsterTooltip()">
                            ${monster.name}
                        </div>
                        <div class="monster-stats-quick">
                            AC ${monster.ac} | HP ${monster.hp} | Init +${monster.initBonus} | ${monster.cr}
                        </div>
                    </div>
                    <div class="monster-actions" style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <label style="font-size: 0.7em; color: #7f8c8d; margin-bottom: 2px;">Poƒçet</label>
                            <input type="number" id="count-${monster.id}" value="1" min="1" max="99" style="width: 65px; text-align: center;" title="Celkov√Ω poƒçet monster">
                        </div>
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <label style="font-size: 0.7em; color: #7f8c8d; margin-bottom: 2px;">Poƒçet skup.</label>
                            <input type="number" id="numgroups-${monster.id}" value="1" min="1" max="99" style="width: 65px; text-align: center;" title="Poƒçet skupin">
                        </div>
                        <button onclick="addMonsterToCombat(${monster.id})" class="btn-success control-btn" title="P≈ôidat do boje">‚ûï</button>
                        <button onclick="openEditMonsterModal(${monster.id})" class="control-btn" style="background: #f39c12;" title="Editovat">‚úèÔ∏è</button>
                        <button onclick="deleteMonsterFromDatabase(${monster.id})" class="btn-danger control-btn" title="Smazat">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('');
        }

        // P≈ôidat monstrum z datab√°ze do boje
        function addMonsterToCombat(monsterId) {
            const monster = monsterDatabase.find(m => m.id === monsterId);
            if (!monster) return;

            // Get count and number of groups from inputs
            const countInput = document.getElementById(`count-${monsterId}`);
            const numGroupsInput = document.getElementById(`numgroups-${monsterId}`);
            const count = parseInt(countInput?.value) || 1;
            const numGroups = parseInt(numGroupsInput?.value) || 1;

            // Calculate group size (how many monsters per group)
            const groupSize = Math.ceil(count / numGroups);

            // Helper function to get group letter (A, B, C, ... Z, AA, AB, ...)
            const getGroupLetter = (index) => {
                let letter = '';
                let num = index;
                while (num >= 0) {
                    letter = String.fromCharCode(65 + (num % 26)) + letter;
                    num = Math.floor(num / 26) - 1;
                }
                return letter;
            };

            let addedCount = 0;
            const timestamp = Date.now();

            for (let groupIndex = 0; groupIndex < numGroups; groupIndex++) {
                const groupLetter = getGroupLetter(groupIndex);
                const groupId = `${monster.name.toLowerCase().replace(/\s/g, '_')}_${timestamp}_${groupLetter}`;
                const groupName = groupLetter;

                // Calculate how many monsters in this group
                const monstersInThisGroup = Math.min(groupSize, count - addedCount);

                for (let i = 0; i < monstersInThisGroup; i++) {
                    const character = {
                        id: timestamp + Math.random() + addedCount,
                        name: getUniqueName(monster.name),  // Pou≈æij inteligentn√≠ ƒç√≠slov√°n√≠
                        type: 'monster',
                        maxHp: monster.hp,
                        currentHp: monster.hp,
                        tempHp: 0,
                        ac: monster.ac,
                        initBonus: monster.initBonus,
                        initiative: null,
                        maxPower: monster.maxPower || 0,
                        currentPower: monster.maxPower || 0,
                        powerName: monster.powerName || 'Power',
                        effects: [],
                        monsterData: monster,
                        groupId: numGroups > 1 ? groupId : null,
                        groupName: numGroups > 1 ? groupName : null,
                        revealedToPlayers: false,  // Monstrum je na zaƒç√°tku skryt√© pro hr√°ƒçe
                        // Spell tracking properties
                        spellcasterLevel: 0,
                        spellSlots: {},
                        customFeatures: [],
                        hitDice: { max: 0, current: 0 }
                    };

                    characters.push(character);
                    addedCount++;
                }
            }

            renderCharacters();
            syncToServer();

            if (count === 1) {
                alert(`${monster.name} p≈ôid√°n do boje!`);
            } else {
                alert(`P≈ôid√°no ${count}x ${monster.name} ve ${numGroups} skupin√°ch!`);
            }
        }

        // Smazat monstrum z datab√°ze
        function deleteMonsterFromDatabase(monsterId) {
            const monster = monsterDatabase.find(m => m.id === monsterId);
            if (!monster) return;

            if (confirm(`Opravdu chcete smazat ${monster.name} z datab√°ze?`)) {
                monsterDatabase = monsterDatabase.filter(m => m.id !== monsterId);
                saveMonsterDatabaseToStorage();
                renderMonsterList();
            }
        }

        // Editace monstra
        function openEditMonsterModal(monsterId) {
            const monster = monsterDatabase.find(m => m.id === monsterId);
            if (!monster) return;

            currentEditingMonsterId = monsterId;

            // Napl≈à formul√°≈ô aktu√°ln√≠mi hodnotami
            document.getElementById('editMonsterName').value = monster.name;
            document.getElementById('editMonsterAC').value = monster.ac;
            document.getElementById('editMonsterHP').value = monster.hp;
            document.getElementById('editMonsterSpeed').value = monster.speed || '30 ft.';
            document.getElementById('editMonsterType').value = monster.type || 'unknown';
            document.getElementById('editMonsterSize').value = monster.size || 'medium';
            document.getElementById('editMonsterPowerName').value = monster.powerName || 'Power';
            document.getElementById('editMonsterMaxPower').value = monster.maxPower || 0;

            document.getElementById('editMonsterModal').style.display = 'block';
        }

        function closeEditMonsterModal() {
            document.getElementById('editMonsterModal').style.display = 'none';
            currentEditingMonsterId = null;
        }

        function saveEditedMonster() {
            if (!currentEditingMonsterId) return;

            const monster = monsterDatabase.find(m => m.id === currentEditingMonsterId);
            if (!monster) return;

            // Aktualizuj hodnoty
            monster.name = document.getElementById('editMonsterName').value;
            monster.ac = parseInt(document.getElementById('editMonsterAC').value) || 10;
            monster.hp = parseInt(document.getElementById('editMonsterHP').value) || 10;
            monster.speed = document.getElementById('editMonsterSpeed').value || '30 ft.';
            monster.type = document.getElementById('editMonsterType').value || 'unknown';
            monster.size = document.getElementById('editMonsterSize').value || 'medium';
            monster.powerName = document.getElementById('editMonsterPowerName').value || 'Power';
            monster.maxPower = parseInt(document.getElementById('editMonsterMaxPower').value) || 0;

            // Ulo≈æ do localStorage a aktualizuj zobrazen√≠
            saveMonsterDatabaseToStorage();
            renderMonsterList();
            closeEditMonsterModal();

            alert('Monstrum aktualizov√°no!');
        }

        // Tooltip syst√©m
        let tooltipElement = null;

        // Pomocn√° funkce pro p≈ôevod markdown na HTML
        function markdownToHtml(text) {
            // P≈ôeveƒè markdown odkazy [text](url) na HTML odkazy
            let html = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');

            // P≈ôeveƒè **bold** na <strong>
            html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

            // Zpracuj ƒç√≠slovan√© seznamy
            const lines = html.split('\n');
            let inList = false;
            let result = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();

                // Detekuj ƒç√≠slovan√Ω seznam
                if (/^\d+\.\s+/.test(line)) {
                    if (!inList) {
                        result.push('<ol style="margin: 5px 0; padding-left: 20px;">');
                        inList = true;
                    }
                    result.push('<li>' + line.replace(/^\d+\.\s+/, '') + '</li>');
                } else {
                    if (inList) {
                        result.push('</ol>');
                        inList = false;
                    }
                    if (line) {
                        result.push(line + '<br>');
                    }
                }
            }

            if (inList) {
                result.push('</ol>');
            }

            return result.join('\n');
        }

        function showMonsterTooltip(event, monsterId) {
            const monster = monsterDatabase.find(m => m.id === monsterId);
            if (!monster) return;

            if (!tooltipElement) {
                tooltipElement = document.createElement('div');
                tooltipElement.className = 'tooltip';
                document.body.appendChild(tooltipElement);
            }

            // Form√°tuj staty s bonusy
            const statStr = (stat) => {
                const bonus = Math.floor((stat - 10) / 2);
                return `${stat} (${bonus >= 0 ? '+' : ''}${bonus})`;
            };

            const statsHtml = `
                <div class="tooltip-section" style="font-size: 0.85em;">
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; text-align: center;">
                        <div><strong>STR</strong><br>${statStr(monster.stats.str)}</div>
                        <div><strong>DEX</strong><br>${statStr(monster.stats.dex)}</div>
                        <div><strong>CON</strong><br>${statStr(monster.stats.con)}</div>
                        <div><strong>INT</strong><br>${statStr(monster.stats.int)}</div>
                        <div><strong>WIS</strong><br>${statStr(monster.stats.wis)}</div>
                        <div><strong>CHA</strong><br>${statStr(monster.stats.cha)}</div>
                    </div>
                </div>
            `;

            const extraInfoHtml = `
                ${monster.savingThrows ? `<p style="font-size: 0.9em; margin: 3px 0;"><strong>Saves:</strong> ${monster.savingThrows}</p>` : ''}
                ${monster.immunities ? `<p style="font-size: 0.9em; margin: 3px 0;"><strong>Immunities:</strong> ${monster.immunities}</p>` : ''}
            `;

            const defensiveTraitsHtml = monster.defensiveTraits && monster.defensiveTraits.length > 0
                ? `<div class="tooltip-section"><h4>Defensive Traits:</h4>${monster.defensiveTraits.slice(0, 1).map(t => `<div style="margin-bottom: 10px;">${markdownToHtml(t)}</div>`).join('')}${monster.defensiveTraits.length > 1 ? '<p><em>...a dal≈°√≠</em></p>' : ''}</div>`
                : '';

            const traitsHtml = monster.traits && monster.traits.length > 0
                ? `<div class="tooltip-section"><h4>Traits:</h4>${monster.traits.slice(0, 2).map(t => `<div style="margin-bottom: 10px;">${markdownToHtml(t)}</div>`).join('')}${monster.traits.length > 2 ? '<p><em>...a dal≈°√≠</em></p>' : ''}</div>`
                : '';

            const actionsHtml = monster.actions && monster.actions.length > 0
                ? `<div class="tooltip-section"><h4>Actions:</h4>${monster.actions.slice(0, 2).map(a => `<div style="margin-bottom: 10px;">${markdownToHtml(a)}</div>`).join('')}${monster.actions.length > 2 ? '<p><em>...a dal≈°√≠</em></p>' : ''}</div>`
                : '';

            const bonusActionsHtml = monster.bonusActions && monster.bonusActions.length > 0
                ? `<div class="tooltip-section"><h4>Bonus Actions:</h4>${monster.bonusActions.slice(0, 1).map(a => `<div style="margin-bottom: 10px;">${markdownToHtml(a)}</div>`).join('')}${monster.bonusActions.length > 1 ? '<p><em>...a dal≈°√≠</em></p>' : ''}</div>`
                : '';

            const reactionsHtml = monster.reactions && monster.reactions.length > 0
                ? `<div class="tooltip-section"><h4>Reactions:</h4>${monster.reactions.slice(0, 1).map(r => `<div style="margin-bottom: 10px;">${markdownToHtml(r)}</div>`).join('')}${monster.reactions.length > 1 ? '<p><em>...a dal≈°√≠</em></p>' : ''}</div>`
                : '';

            tooltipElement.innerHTML = `
                <h4>${monster.name}</h4>
                <div class="tooltip-section">
                    <p><strong>${monster.size} ${monster.type}</strong></p>
                    <p>AC ${monster.ac}, HP ${monster.hp}, Speed ${monster.speed}</p>
                    ${extraInfoHtml}
                </div>
                ${statsHtml}
                ${defensiveTraitsHtml}
                ${traitsHtml}
                ${actionsHtml}
                ${bonusActionsHtml}
                ${reactionsHtml}
            `;

            tooltipElement.classList.add('show');
            positionTooltip(event);
        }

        function hideMonsterTooltip() {
            if (tooltipElement) {
                tooltipElement.classList.remove('show');
            }
        }

        function positionTooltip(event) {
            if (!tooltipElement) return;

            const x = event.clientX + 10;
            const y = event.clientY + 10;

            tooltipElement.style.position = 'fixed';
            tooltipElement.style.left = x + 'px';
            tooltipElement.style.top = y + 'px';
        }

        // Export/Import datab√°ze
        function exportMonsterDatabase() {
            const data = {
                monsters: monsterDatabase,
                timestamp: new Date().toISOString()
            };

            const defaultName = `dnd-monster-database-${new Date().toISOString().split('T')[0]}`;
            openFileNameModal('üíæ Exportovat datab√°zi monster', defaultName, data, downloadJsonFile);
        }

        function importMonsterDatabase(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.monsters && Array.isArray(data.monsters)) {
                        monsterDatabase = data.monsters;
                        saveMonsterDatabaseToStorage();
                        renderMonsterList();
                        alert(`√öspƒõ≈°nƒõ importov√°no ${data.monsters.length} monster!`);
                    } else {
                        alert('Neplatn√Ω form√°t datab√°ze!');
                    }
                } catch (error) {
                    alert('Chyba p≈ôi naƒç√≠t√°n√≠ datab√°ze!');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function clearMonsterDatabase() {
            if (!confirm('Opravdu chcete vymazat celou datab√°zi monster?\n\nTato akce je nevratn√°!')) {
                return;
            }

            monsterDatabase = [];
            saveMonsterDatabaseToStorage();
            renderMonsterList();
            syncToServer();
            alert('Datab√°ze monster byla vyƒçi≈°tƒõna.');
        }

        // ===== FILE NAME MODAL FUNCTIONS =====
        let fileNameCallback = null;
        let currentFileData = null;

        function openFileNameModal(title, defaultName, data, callback) {
            document.getElementById('fileNameModalTitle').textContent = title;
            document.getElementById('fileNameInput').value = defaultName;
            currentFileData = data;
            fileNameCallback = callback;
            document.getElementById('fileNameModal').style.display = 'block';

            // Focus na input a vybrat text
            setTimeout(() => {
                const input = document.getElementById('fileNameInput');
                input.focus();
                input.select();
            }, 100);
        }

        function closeFileNameModal() {
            document.getElementById('fileNameModal').style.display = 'none';
            fileNameCallback = null;
            currentFileData = null;
        }

        function confirmFileName() {
            const fileName = document.getElementById('fileNameInput').value.trim();
            if (!fileName) {
                alert('Pros√≠m zadejte n√°zev souboru!');
                return;
            }

            if (fileNameCallback && currentFileData) {
                fileNameCallback(fileName, currentFileData);
            }

            closeFileNameModal();
        }

        // Podpora pro Enter key v inputu
        document.addEventListener('DOMContentLoaded', function() {
            const fileNameInput = document.getElementById('fileNameInput');
            if (fileNameInput) {
                fileNameInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        confirmFileName();
                    }
                });
            }
        });

        // Helper funkce pro sta≈æen√≠ souboru
        function downloadJsonFile(fileName, data) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${fileName}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Notion link import (placeholder)
        function importFromNotion() {
            const link = document.getElementById('notionLinkInput').value;
            if (!link.trim()) {
                alert('Vlo≈æte pros√≠m Notion link!');
                return;
            }

            alert('Notion API import nen√≠ zat√≠m implementov√°n. Pros√≠m pou≈æijte copy/paste statblocku do textarea n√≠≈æe.');
            // TODO: Implementovat Notion API fetch
        }

        // Toggle statblock panel
        function toggleStatblock(charId) {
            const panel = document.getElementById(`statblock-${charId}`);
            if (panel) {
                panel.classList.toggle('show');
            }
        }

        // P≈ôeddefinovan√© D&D 5e kondice/efekty
        const predefinedEffects = {
            // Debuffs
            'Blinded': { type: 'debuff', description: 'Postava nevid√≠ a automaticky neuspƒõje u kontrol zalo≈æen√Ωch na zraku. √ötoky proti postavƒõ maj√≠ v√Ωhodu, √∫toky postavy maj√≠ nev√Ωhodu.' },
            'Charmed': { type: 'debuff', description: 'Postava nem≈Ø≈æe √∫toƒçit na toho, kdo ji okouzlil. Ten m√° v√Ωhodu na soci√°ln√≠ interakce.' },
            'Deafened': { type: 'debuff', description: 'Postava nesly≈°√≠ a automaticky neuspƒõje u kontrol zalo≈æen√Ωch na sluchu.' },
            'Frightened': { type: 'debuff', description: 'Postava m√° nev√Ωhodu na ability checks a √∫toky, dokud je zdroj strachu ve v√Ωhledu. Nem≈Ø≈æe se dobrovolnƒõ p≈ôibl√≠≈æit ke zdroji.' },
            'Grappled': { type: 'debuff', description: 'Rychlost postavy je 0. Konƒç√≠, kdy≈æ je grappler neschopn√Ω nebo postava unikne.' },
            'Incapacitated': { type: 'debuff', description: 'Postava nem≈Ø≈æe prov√°dƒõt akce ani reakce.' },
            'Paralyzed': { type: 'debuff', description: 'Postava je neschopn√° a nem≈Ø≈æe se h√Ωbat ani mluvit. Automaticky neuspƒõje u Str a Dex z√°chran. √ötoky proti n√≠ maj√≠ v√Ωhodu.' },
            'Petrified': { type: 'debuff', description: 'Postava je zkamenƒõl√°, neschopn√° a neuvƒõdomƒõl√°. M√° odolnost proti v≈°em typ≈Øm po≈°kozen√≠.' },
            'Poisoned': { type: 'debuff', description: 'Postava m√° nev√Ωhodu na √∫toky a ability checks.' },
            'Prone': { type: 'debuff', description: 'Pohyb pouze plazen√≠m. Nev√Ωhoda na √∫toky. √ötoky zbl√≠zka maj√≠ v√Ωhodu, na d√°lku nev√Ωhodu.' },
            'Restrained': { type: 'debuff', description: 'Rychlost 0, nev√Ωhoda na √∫toky a Dex z√°chrann√© hody. √ötoky proti postavƒõ maj√≠ v√Ωhodu.' },
            'Stunned': { type: 'debuff', description: 'Postava je neschopn√°, nem≈Ø≈æe se h√Ωbat a mluv√≠ jen nejasnƒõ. Automaticky neuspƒõje u Str a Dex z√°chran.' },
            'Unconscious': { type: 'debuff', description: 'Postava je neschopn√°, nem≈Ø≈æe se h√Ωbat ani mluvit, neuvƒõdomƒõl√°. Automaticky neuspƒõje u Str a Dex z√°chran.' },
            'Defenseless': { type: 'debuff', description: 'Attack rolls against you have advantage.' },
            'Impaired': { type: 'debuff', description: 'Your speed is halved.' },
            'Distracted': { type: 'debuff', description: 'You can not take reactions.' },
            'Hexblade_Curse': { type: 'debuff', description: 'Nif does extra necrotic damage, crits on 1 less and heals if it dies.' },
            'Moonlit': { type: 'debuff', description: 'Produce moonlight in 20 ft radius and cannot be invisible.' },
            'Confused': { type: 'debuff', description: 'You can not take Bonus Actions or Reactions and must roll 1d10 at the start of each of your turns to determine your behavior for that turn, consulting the table below: 1 - You do not take an action, and use all your movement to move. Roll 1d4 for the direction: 1, north; 2, east; 3, south; or 4, west. 2-6 You do not move or take actions. 7-8 You do not move, and take your Attack action to make one melee attack against a random creature within reach. If none are within reach, you take no action. 9-10 You hold your mind together and choose your behavior.' },
            'Exhaustion': {
                type: 'debuff',
                hasLevels: true,
                maxLevel: 6,
                description: 'Level 1: Disadvantage on ability checks. Level 2: Speed halved. Level 3: Disadvantage on attack rolls and enemies adv. on saving throws against your effects. Level 4: Disadvantage on saving throws. Level 5: Speed reduced to 0. Level 6: Death.'
            },
            'Divine_Ire': {
                type: 'debuff',
                hasLevels: true,
                maxLevel: 6,
                description: 'Level 1: Disadvantage on Charisma ability checks and you can hear the voice of the deity that you angered. Level 2: 1st Domain Effect. Level 3: You cannot be resistant to damage done by servants of this god. Immunity to their damage is reduced to resistance instead. Level 4: 2nd Domain Effect. Level 5: Hit point maximum halved. Level 6: You stricken down by divine wrath. You die and your body disintegrates in a flash of divine light.'
            },
            'Divine_Ire_Cyric': {
                type: 'debuff',
                hasLevels: true,
                maxLevel: 6,
                description: 'Level 1: Disadvantage on Charisma ability checks and you can hear the voice of the deity that you angered. Level 2: Dark light coalesces around you marking you for the hunt. You are Defenseless and cannot be Invisible. Level 3: You cannot be resistant to damage done by servants of this god. Immunity to their damage is reduced to resistance instead. Level 4: At the start of your turn Save: DC 24 Wisdom saving throw, Failure: You are Confused this turn. Level 5: Hit point maximum halved. Level 6: You stricken down by divine wrath. You die and your body disintegrates in a flash of divine light.'
            },

            // Buffs
            'Invisible': { type: 'buff', description: 'Postava je neviditeln√°. √ötoky proti n√≠ maj√≠ nev√Ωhodu, jej√≠ √∫toky maj√≠ v√Ωhodu.' },
            'Hasted': { type: 'buff', description: 'Double speed, +2 AC, adv on Dex saves, extra action (one attack, dash, disengage, hide or use an object).' },
            'Inspired': { type: 'buff', description: 'Bardic Inspiration - bonus d12 to a d20 roll.' },
            'Heroic_Inspiration': { type: 'buff', description: 'A d20 reroll.' },
            'Spirit_Shroud': { type: 'buff', description: 'Extra damage and movement reduction to enemies.' },
            'Tensor_Transformation': { type: 'buff', description: 'Super powered Wizard go.' },
            'Retaliation_Aura': { type: 'buff', description: 'Punch back.' },
            'Foresight': { type: 'buff', description: 'All advantages.' },
            'Elder_Champion': { type: 'buff', description: 'Spells are bonus actions, heals 10 HP (20) each round and enemies dis on saves against her spells.' },
            'Celestial_Revelation': { type: 'buff', description: 'Flies (double movement), proficiency damage aura or fear aura.' },
            'Power_of_Mercy': { type: 'buff', description: 'Resistance to everything and enemies take back half damage dealt as radiant.' },
            'Sacred_Divine_Sense': { type: 'buff', description: 'Epic advantage against fiends, undead, celestials and daemons. Last until the end of NEXT round' },
            'Protective_Spirit': { type: 'buff', description: 'Heals 16 HP if bloodied at end of round.' },
            'Emissary_of_Redemtion': { type: 'buff', description: 'Half damage from creatures you did not attack yet and they take half damage back as radiant.' },
            'Rythm_of_War': { type: 'buff', description: 'Advantage on all saves AOE based on spell level.' },
            
            // Neutr√°ln√≠/Situaƒçn√≠
            'Irredeemable': { type: 'neutral', description: 'Attacked by Crow. Is not affected by emissary of redemption.' },
            'Not_Harmonized': { type: 'neutral', description: 'Harmonize unused.' },
            'Concentrating': { type: 'neutral', description: 'Postava se soust≈ôed√≠ na kouzlo. P≈ôi po≈°kozen√≠ h√°z√≠ z√°chrann√Ω hod na koncentraci.' },
            'Marked': { type: 'neutral', description: 'Postava je oznaƒçen√° pro sledov√°n√≠ nebo speci√°ln√≠ efekt.' },
            'Raging': { type: 'buff', description: 'Barbarian Rage - bonus k po≈°kozen√≠, odolnost proti fyzick√©mu po≈°kozen√≠.' },
            'Dodging': { type: 'buff', description: 'Postava se vyh√Ωb√° - √∫toky proti n√≠ maj√≠ nev√Ωhodu.' }
        };

        function addCharacter() {
            const name = document.getElementById('name').value.trim();
            const type = document.getElementById('type').value;
            const maxHp = parseInt(document.getElementById('maxHp').value);
            const currentHp = parseInt(document.getElementById('currentHp').value) || maxHp;
            const ac = parseInt(document.getElementById('ac').value) || 10;
            const initBonus = parseInt(document.getElementById('initBonus').value) || 0;
            const maxPower = parseInt(document.getElementById('maxPower').value) || 0;
            const currentPower = parseInt(document.getElementById('currentPower').value) || maxPower;

            if (!name || !maxHp) {
                alert('Vypl≈àte pros√≠m jm√©no a maxim√°ln√≠ HP!');
                return;
            }

            const character = {
                id: Date.now() + Math.random(),
                name: getUniqueName(name),  // Pou≈æij inteligentn√≠ ƒç√≠slov√°n√≠ i pro hr√°ƒçe
                type,
                maxHp,
                currentHp,
                tempHp: 0,
                ac,
                initBonus,
                initiative: null,
                maxPower,
                currentPower,
                effects: [],
                // Spell tracking properties
                spellcasterLevel: 0,
                spellSlots: {},
                customFeatures: [],
                hitDice: { max: 0, current: 0 }
            };

            characters.push(character);

            // Vymaz√°n√≠ formul√°≈ôe
            document.getElementById('name').value = '';
            document.getElementById('maxHp').value = '';
            document.getElementById('currentHp').value = '';
            document.getElementById('ac').value = '';
            document.getElementById('initBonus').value = '';
            document.getElementById('maxPower').value = '';
            document.getElementById('currentPower').value = '';

            renderCharacters();
            syncToServer();
        }

        function duplicateMonster(id) {
            const original = characters.find(char => char.id === id);
            if (!original || original.type !== 'monster') return;

            // Najdi v≈°echny monstra se stejn√Ωm z√°kladn√≠m jm√©nem
            const baseName = original.name.replace(/^\d+\.\s*/, ''); // Odstra≈à ƒç√≠slo z zaƒç√°tku
            const similarMonsters = characters.filter(char => 
                char.type === 'monster' && 
                (char.name === baseName || char.name.includes(baseName))
            );

            // P≈ôeƒç√≠sluj v≈°echna podobn√° monstra
            similarMonsters.forEach((monster, index) => {
                monster.name = `${index + 1}. ${baseName}`;
            });

            // Vytvo≈ô kopii
            const newMonster = {
                ...original,
                id: Date.now() + Math.random(),
                name: `${similarMonsters.length + 1}. ${baseName}`,
                initiative: null,
                currentHp: original.maxHp,
                currentPower: original.maxPower,
                tempHp: 0,
                effects: [...original.effects],
                revealedToPlayers: false  // Nov√© monstrum je tak√© skryt√©
            };

            characters.push(newMonster);
            renderCharacters();
            syncToServer();
        }

        function unlinkFromGroup(id) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (character && character.groupId) {
                character.groupId = null;
                character.groupName = null;
                renderCharacters();
                syncToServer();
            }
        }

        function removeCharacter(id) {
            saveState();
            characters = characters.filter(char => char.id !== id);
            renderCharacters();
            syncToServer();
        }

        function updateHp(id, change) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (!character) return;

            if (change < 0) {
                let damage = -change;
                if (character.tempHp > 0) {
                    const tempDamage = Math.min(character.tempHp, damage);
                    character.tempHp -= tempDamage;
                    damage -= tempDamage;
                }
                if (damage > 0) {
                    character.currentHp = Math.max(0, character.currentHp - damage);
                }
            } else if (change > 0) {
                character.currentHp = Math.min(character.maxHp, character.currentHp + change);
            }
            renderCharacters();
            syncToServer();
        }

        function applyCustomDamage(id) {
            const input = document.querySelector(`[data-damage-id="${id}"]`);
            const damage = parseInt(input.value) || 0;
            if (damage > 0) {
                updateHp(id, -damage);
                input.value = '';
            }
        }

        function applyCustomHealing(id) {
            const input = document.querySelector(`[data-healing-id="${id}"]`);
            const healing = parseInt(input.value) || 0;
            if (healing > 0) {
                updateHp(id, healing);
                input.value = '';
            }
        }

        function setTempHp(id) {
            saveState();
            const input = document.querySelector(`[data-temp-id="${id}"]`);
            const tempHp = parseInt(input.value) || 0;
            const character = characters.find(char => char.id === id);
            if (character) {
                character.tempHp = Math.max(0, tempHp);
                input.value = '';
                renderCharacters();
                syncToServer();
            }
        }

        function applyMaxHpChange(id) {
            saveState();
            const input = document.querySelector(`[data-maxhp-id="${id}"]`);
            const change = parseInt(input.value) || 0;
            if (change === 0) return;
            const character = characters.find(char => char.id === id);
            if (!character) return;
            character.maxHp += change;
            if (character.currentHp > character.maxHp) {
                character.currentHp = character.maxHp;
            }
            const effectName = `Max HP ${change >= 0 ? '+' : ''}${change}`;
            character.effects.push(effectName);
            input.value = '';
            renderCharacters();
            syncToServer();
            if (currentEffectCharacterId === id) {
                renderEffects();
            }
        }

        function updatePower(id, change) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (character) {
                character.currentPower = Math.max(0, character.currentPower + change);
                renderCharacters();
                syncToServer();
            }
        }

        function setPower(id, value) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (character) {
                character.currentPower = Math.max(0, parseInt(value) || 0);
                renderCharacters();
                syncToServer();
            }
        }

        function setInitiative(id, value) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (character) {
                const oldInitiative = character.initiative;
                character.initiative = parseInt(value) || null;

                // If character is in a group, update all group members
                if (character.groupId) {
                    characters.forEach(char => {
                        if (char.groupId === character.groupId && char.id !== id) {
                            char.initiative = character.initiative;
                        }
                    });
                }

                // Pokud prob√≠h√° boj, p≈ôeorganizuj po≈ôad√≠
                if (combatState.active && character.initiative !== null) {
                    // Se≈ôaƒè znovu podle iniciativy
                    const currentCharIndex = combatState.currentTurn;
                    const currentCharId = characters[currentCharIndex].id;
                    
                    characters.sort((a, b) => b.initiative - a.initiative);
                    
                    // Najdi novou pozici aktu√°ln√≠ postavy
                    const newCurrentIndex = characters.findIndex(char => char.id === currentCharId);
                    
                    // Najdi novou pozici upraven√© postavy
                    const updatedCharIndex = characters.findIndex(char => char.id === id);
                    
                    // Pokud se upraven√° postava dostala p≈ôed aktu√°ln√≠ postavu, oznaƒçit ji jako hranou
                    if (updatedCharIndex < newCurrentIndex && !combatState.playedThisRound.includes(updatedCharIndex)) {
                        combatState.playedThisRound.push(updatedCharIndex);
                    }
                    
                    // Aktualizuj souƒçasn√Ω tah
                    combatState.currentTurn = newCurrentIndex;
                    
                    // P≈ôepoƒç√≠tej kdo u≈æ hr√°l v tomto kole
                    combatState.playedThisRound = combatState.playedThisRound
                        .map(oldIndex => {
                            // Najdi postavu podle p≈Øvodn√≠ho indexu a vra≈• jej√≠ nov√Ω index
                            const charAtOldIndex = characters.find((char, idx) => idx === oldIndex);
                            return charAtOldIndex ? characters.findIndex(c => c.id === charAtOldIndex.id) : -1;
                        })
                        .filter(idx => idx !== -1 && idx < newCurrentIndex);
                    
                    updateInitiativeDisplay();
                }

                renderCharacters();
                syncToServer();
            }
        }

        function rollInitiative(character) {
            const roll = Math.floor(Math.random() * 20) + 1;
            return roll + character.initBonus;
        }

        function startCombat() {
            // Hoƒè iniciativou pro v≈°echny bez iniciativy
            const processedGroups = new Set();

            characters.forEach(char => {
                if (char.initiative === null) {
                    const initiative = rollInitiative(char);
                    char.initiative = initiative;

                    // If character is in a group, apply same initiative to all group members
                    if (char.groupId && !processedGroups.has(char.groupId)) {
                        processedGroups.add(char.groupId);
                        characters.forEach(c => {
                            if (c.groupId === char.groupId && c.id !== char.id) {
                                c.initiative = initiative;
                            }
                        });
                    }
                }
            });

            // Se≈ôaƒè podle iniciativy
            characters.sort((a, b) => b.initiative - a.initiative);

            combatState.active = true;
            combatState.currentTurn = 0;
            combatState.round = 1;
            combatState.playedThisRound = [];

            // Odhal prvn√≠ postavu na tahu (pokud je to monstrum)
            const firstChar = characters[0];
            if (firstChar && firstChar.type === 'monster') {
                firstChar.revealedToPlayers = true;
            }

            document.getElementById('startBtn').classList.add('hidden');
            document.getElementById('prevBtn').classList.remove('hidden');
            document.getElementById('nextBtn').classList.remove('hidden');
            document.getElementById('endBtn').classList.remove('hidden');
            document.getElementById('closeBtn').classList.remove('hidden');
            document.getElementById('saveCombatBtn').style.display = 'inline-block';

            updateInitiativeDisplay();
            renderCharacters();
            syncToServer();
            saveAutosave(); // Autosave when combat starts
        }

        function nextTurn() {
            saveState();

            // Odhal aktu√°ln√≠ postavu pro hr√°ƒçe (pokud je to monstrum)
            const currentChar = characters[combatState.currentTurn];
            if (currentChar && currentChar.type === 'monster') {
                currentChar.revealedToPlayers = true;
            }

            if (combatState.currentTurn < characters.length - 1) {
                combatState.playedThisRound.push(combatState.currentTurn);
                combatState.currentTurn++;
            } else {
                // Nov√© kolo
                combatState.round++;
                combatState.currentTurn = 0;
                combatState.playedThisRound = [];

                // Autosave at the start of new round (except first round)
                if (combatState.round > 1) {
                    saveAutosave();
                }
            }

            // Odhal novou postavu na tahu (pokud je to monstrum)
            const newChar = characters[combatState.currentTurn];
            if (newChar && newChar.type === 'monster') {
                newChar.revealedToPlayers = true;

                // Reset legendary actions at the start of monster's turn
                if (newChar.monsterAbilities && newChar.monsterAbilities.legendaryActions && newChar.monsterAbilities.legendaryActions.enabled) {
                    newChar.monsterAbilities.legendaryActions.used = 0;
                }
            }

            updateInitiativeDisplay();
            renderCharacters();
            syncToServer();
        }

        function previousTurn() {
            saveState();
            if (combatState.currentTurn > 0) {
                combatState.currentTurn--;
                // Odstra≈à z playedThisRound pokud tam byl
                combatState.playedThisRound = combatState.playedThisRound.filter(idx => idx !== combatState.currentTurn);
            } else {
                // Vr√°tit se na konec p≈ôedchoz√≠ho kola
                if (combatState.round > 1) {
                    combatState.round--;
                    combatState.currentTurn = characters.length - 1;
                    // V p≈ôedchoz√≠m kole v≈°ichni hr√°li kromƒõ posledn√≠ho
                    combatState.playedThisRound = Array.from({length: characters.length - 1}, (_, i) => i);
                }
            }

            updateInitiativeDisplay();
            renderCharacters();
            syncToServer();
        }

        function endCombat() {
            combatState.active = false;
            combatState.currentTurn = 0;
            combatState.round = 1;
            combatState.playedThisRound = [];

            // Reset pouze initiative, efekty Z≈ÆST√ÅVAJ√ç, HP z≈Øst√°v√°
            characters.forEach(char => {
                char.initiative = null;
                // Resetuj Moc pouze u monster
                if (char.type === 'monster') {
                    char.currentPower = char.maxPower;
                    // Skryj monstra zpƒõt pro hr√°ƒçe
                    char.revealedToPlayers = false;
                }
            });

            document.getElementById('startBtn').classList.remove('hidden');
            document.getElementById('prevBtn').classList.add('hidden');
            document.getElementById('nextBtn').classList.add('hidden');
            document.getElementById('endBtn').classList.add('hidden');
            document.getElementById('closeBtn').classList.add('hidden');
            document.getElementById('saveCombatBtn').style.display = 'none';
            document.getElementById('initiativeOrder').classList.add('hidden');

            renderCharacters();
            syncToServer();
            saveAutosave(); // Autosave when combat ends
        }

        function closeCombat() {
            combatState.active = false;
            combatState.currentTurn = 0;
            combatState.round = 1;
            combatState.playedThisRound = [];

            // Odstra≈à v≈°echna monstra, u hr√°ƒç≈Ø reset pouze iniciativy, efekty Z≈ÆST√ÅVAJ√ç
            characters = characters.filter(char => {
                if (char.type === 'player') {
                    char.initiative = null;
                    // HP a efekty z≈Øst√°vaj√≠
                    return true;
                }
                return false;
            });

            document.getElementById('startBtn').classList.remove('hidden');
            document.getElementById('prevBtn').classList.add('hidden');
            document.getElementById('nextBtn').classList.add('hidden');
            document.getElementById('endBtn').classList.add('hidden');
            document.getElementById('closeBtn').classList.add('hidden');
            document.getElementById('saveCombatBtn').style.display = 'none';
            document.getElementById('initiativeOrder').classList.add('hidden');

            renderCharacters();
            syncToServer();
            saveAutosave(); // Autosave when combat is closed
        }

        function openEffectModal(id) {
            currentEffectCharacterId = id;
            const character = characters.find(char => char.id === id);
            document.getElementById('effectCharacterName').textContent = character.name;
            renderEffects();
            document.getElementById('effectModal').style.display = 'block';
        }

        function closeEffectModal() {
            document.getElementById('effectModal').style.display = 'none';
            currentEffectCharacterId = null;
        }

        // Helper funkce pro pr√°ci s efekty
        function normalizeEffect(effect) {
            // P≈ôevede star√Ω string form√°t nebo objekt na jednotn√Ω form√°t
            if (typeof effect === 'string') {
                return { name: effect, level: null };
            }
            return effect;
        }

        function effectToString(effect) {
            const normalized = normalizeEffect(effect);
            if (normalized.level !== null && normalized.level !== undefined) {
                return `${normalized.name} ${normalized.level}`;
            }
            return normalized.name;
        }

        function findEffectIndex(effects, effectName) {
            return effects.findIndex(e => {
                const norm = normalizeEffect(e);
                return norm.name === effectName;
            });
        }

        function addEffect() {
            saveState();
            const effectSelect = document.getElementById('effectSelect');
            const customInput = document.getElementById('newEffect');

            let effectName = '';
            if (effectSelect.value) {
                effectName = effectSelect.value;
                effectSelect.value = '';
            } else if (customInput.value.trim()) {
                effectName = customInput.value.trim();
                customInput.value = '';
            }

            if (!effectName || !currentEffectCharacterId) return;

            const character = characters.find(char => char.id === currentEffectCharacterId);

            // Zkontroluj jestli efekt u≈æ m√°
            const existingIndex = findEffectIndex(character.effects, effectName);
            if (existingIndex === -1) {
                // P≈ôidej nov√Ω efekt
                const effectDef = predefinedEffects[effectName];
                if (effectDef && effectDef.hasLevels) {
                    character.effects.push({ name: effectName, level: 1 });
                } else {
                    character.effects.push({ name: effectName, level: null });
                }
                renderEffects();
                renderCharacters();
                syncToServer();
            }
        }

        function handleEffectRemoval(character, effectName) {
            const match = effectName.match(/^Max HP ([+-]?\d+)/);
            if (match) {
                const amount = parseInt(match[1]);
                character.maxHp -= amount;
                if (character.currentHp > character.maxHp) {
                    character.currentHp = character.maxHp;
                }
            }
        }

        function changeEffectLevel(effectIndex, delta) {
            saveState();
            const character = characters.find(char => char.id === currentEffectCharacterId);
            if (!character) return;

            const effect = normalizeEffect(character.effects[effectIndex]);
            const effectDef = predefinedEffects[effect.name];

            if (effectDef && effectDef.hasLevels) {
                const newLevel = Math.max(1, Math.min(effectDef.maxLevel, (effect.level || 1) + delta));
                character.effects[effectIndex] = { name: effect.name, level: newLevel };
                renderEffects();
                renderCharacters();
                syncToServer();
            }
        }

        function removeEffect(effectIndex) {
            saveState();
            const character = characters.find(char => char.id === currentEffectCharacterId);
            const effect = normalizeEffect(character.effects[effectIndex]);
            handleEffectRemoval(character, effect.name);
            character.effects.splice(effectIndex, 1);
            renderEffects();
            renderCharacters();
            syncToServer();
        }

        function removeEffectFromCharacter(id, effectIndex) {
            saveState();
            const character = characters.find(char => char.id === id);
            if (!character) return;
            const effect = normalizeEffect(character.effects[effectIndex]);
            const effectDef = predefinedEffects[effect.name];

            // Pokud efekt m√° levely a level > 1, sni≈æ level m√≠sto odstranƒõn√≠
            if (effectDef && effectDef.hasLevels && effect.level && effect.level > 1) {
                character.effects[effectIndex] = { name: effect.name, level: effect.level - 1 };
            } else {
                // Level 1 nebo efekt bez level≈Ø - odstranit
                handleEffectRemoval(character, effect.name);
                character.effects.splice(effectIndex, 1);
            }

            if (currentEffectCharacterId === id) {
                renderEffects();
            }
            renderCharacters();
            syncToServer();
        }

        function getEffectClass(effect) {
            const normalized = normalizeEffect(effect);
            if (predefinedEffects[normalized.name]) {
                return predefinedEffects[normalized.name].type;
            }
            const match = normalized.name.match(/^Max HP ([+-]?\d+)/);
            if (match) {
                return parseInt(match[1]) >= 0 ? 'buff' : 'debuff';
            }
            return 'neutral'; // Vlastn√≠ efekty jsou neutr√°ln√≠
        }

        function getEffectDescription(effect) {
            const normalized = normalizeEffect(effect);
            if (predefinedEffects[normalized.name]) {
                return predefinedEffects[normalized.name].description;
            }
            const match = normalized.name.match(/^Max HP ([+-]?\d+)/);
            if (match) {
                const amount = parseInt(match[1]);
                return `Maxim√°ln√≠ HP ${amount >= 0 ? 'zv√Ω≈°eno' : 'sn√≠≈æeno'} o ${Math.abs(amount)}`;
            }
            return 'Vlastn√≠ efekt - bez popisu';
        }

        function renderEffects() {
            const character = characters.find(char => char.id === currentEffectCharacterId);
            const effectList = document.getElementById('effectList');

            if (character.effects.length === 0) {
                effectList.innerHTML = '<p style="color: #7f8c8d; font-style: italic;">≈Ω√°dn√© aktivn√≠ efekty</p>';
                return;
            }

            effectList.innerHTML = `
                <div class="effect-list-container">
                    ${character.effects.map((effect, index) => {
                        const normalized = normalizeEffect(effect);
                        const effectDef = predefinedEffects[normalized.name];
                        const hasLevels = effectDef && effectDef.hasLevels;
                        const displayText = effectToString(effect);

                        return `
                            <div class="effect-item">
                                <div style="flex: 1;">
                                    <span class="effect-tag ${getEffectClass(effect)}" title="${getEffectDescription(effect)}">${displayText}</span>
                                    <div class="effect-description">${getEffectDescription(effect)}</div>
                                    ${hasLevels ? `
                                        <div style="margin-top: 5px;">
                                            <button onclick="changeEffectLevel(${index}, -1)" class="btn-danger control-btn" style="font-size: 0.7em;">-</button>
                                            <span style="margin: 0 5px; font-weight: bold;">Level ${normalized.level || 1}</span>
                                            <button onclick="changeEffectLevel(${index}, 1)" class="btn-success control-btn" style="font-size: 0.7em;">+</button>
                                        </div>
                                    ` : ''}
                                </div>
                                <button onclick="removeEffect(${index})" class="btn-danger control-btn">‚úï</button>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // Helper funkce - vr√°t√≠ jen postavy viditeln√© pro aktu√°ln√≠ view mode
        function getVisibleCharacters() {
            if (isDM) {
                return characters; // DM vid√≠ v≈°echno
            }
            // Hr√°ƒçi vid√≠ jen hr√°ƒçe a odhalen√° monstra
            return characters.filter(char =>
                char.type === 'player' || (char.type === 'monster' && char.revealedToPlayers)
            );
        }

        function updateInitiativeDisplay() {
            const orderDiv = document.getElementById('initiativeOrder');
            if (combatState.active && characters.length > 0) {
                const currentChar = characters[combatState.currentTurn];
                const visibleChars = getVisibleCharacters();

                // V player m√≥du zobraz√≠me pouze odhalen√© postavy
                const displayChars = isPlayer ? visibleChars : characters;

                orderDiv.innerHTML = `
                    <div class="turn-info">Kolo ${combatState.round} - Na tahu: ${currentChar.revealedToPlayers || currentChar.type === 'player' || isDM ? currentChar.name : '???'} ${(currentChar.revealedToPlayers || currentChar.type === 'player' || isDM) ? `(Iniciativa: ${currentChar.initiative})` : ''}</div>
                    <div>Po≈ôad√≠ iniciativy: ${displayChars.map((char, index) => {
                        // Najdi skuteƒçn√Ω index v p≈Øvodn√≠m characters array
                        const realIndex = characters.findIndex(c => c.id === char.id);
                        return `<span style="color: ${realIndex === combatState.currentTurn ? '#f39c12' :
                        combatState.playedThisRound.includes(realIndex) ? '#7f8c8d' : '#2c3e50'}">${char.name} (${char.initiative})</span>`;
                    }).join(' ‚Üí ')}</div>
                `;
                orderDiv.classList.remove('hidden');
            } else {
                orderDiv.classList.add('hidden');
            }
        }

        // Helper pro Player mode - barevn√Ω indik√°tor zdrav√≠ monster
        function getMonsterHealthIndicator(currentHp, maxHp) {
            const percentage = (currentHp / maxHp) * 100;
            if (percentage > 50) return 'üü¢ Healthy';
            if (percentage > 25) return 'üü° Bloodied';
            return 'üî¥ Critical';
        }

        function getHpBarClass(currentHp, maxHp) {
            const percentage = (currentHp / maxHp) * 100;
            if (percentage <= 25) return 'low';
            if (percentage <= 50) return 'medium';
            return '';
        }

        // Generate consistent color for group based on groupId
        function getGroupColor(groupId) {
            if (!groupId) return '#95a5a6';

            // Predefined color palette for groups
            const colors = [
                '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
                '#1abc9c', '#e67e22', '#16a085', '#d35400', '#8e44ad',
                '#c0392b', '#2980b9', '#27ae60', '#f1c40f', '#34495e'
            ];

            // Generate hash from groupId
            let hash = 0;
            for (let i = 0; i < groupId.length; i++) {
                hash = groupId.charCodeAt(i) + ((hash << 5) - hash);
            }

            // Use hash to select color
            const index = Math.abs(hash) % colors.length;
            return colors[index];
        }

        // LocalStorage funkce pro auto-save
        function saveToLocalStorage() {
            try {
                const data = {
                    characters: characters.map(char => ({
                        name: char.name,
                        type: char.type,
                        maxHp: char.maxHp,
                        currentHp: char.currentHp,
                        tempHp: char.tempHp,
                        ac: char.ac,
                        initBonus: char.initBonus,
                        maxPower: char.maxPower,
                        currentPower: char.currentPower,
                        powerName: char.powerName,
                        effects: char.effects,
                        initiative: char.initiative,
                        monsterData: char.monsterData,
                        groupId: char.groupId,
                        groupName: char.groupName,
                        // Spell tracking properties
                        spellcasterLevel: char.spellcasterLevel,
                        spellSlots: char.spellSlots,
                        customFeatures: char.customFeatures,
                        hitDice: char.hitDice
                    })),
                    combatState: combatState,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('dnd-tracker-data', JSON.stringify(data));
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }

        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('dnd-tracker-data');
                if (saved) {
                    const data = JSON.parse(saved);
                    if (data.characters && Array.isArray(data.characters)) {
                        characters = data.characters.map(char => ({
                            ...char,
                            id: Date.now() + Math.random(),
                            tempHp: char.tempHp || 0,
                            ac: char.ac || 10,
                            effects: char.effects || [],
                            initiative: char.initiative || null,
                            groupId: char.groupId || null,
                            groupName: char.groupName || null,
                            // Spell tracking properties
                            spellcasterLevel: char.spellcasterLevel || 0,
                            spellSlots: char.spellSlots || {},
                            customFeatures: char.customFeatures || [],
                            hitDice: char.hitDice || { max: 0, current: 0 }
                        }));

                        if (data.combatState) {
                            combatState = data.combatState;
                        }

                        renderCharacters();

                        // Obnovit UI tlaƒç√≠tka podle stavu boje
                        if (combatState.active) {
                            document.getElementById('startBtn').classList.add('hidden');
                            document.getElementById('prevBtn').classList.remove('hidden');
                            document.getElementById('nextBtn').classList.remove('hidden');
                            document.getElementById('endBtn').classList.remove('hidden');
                            document.getElementById('closeBtn').classList.remove('hidden');
                            document.getElementById('saveCombatBtn').style.display = 'inline-block';
                            updateInitiativeDisplay();
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
            }
        }

        // ===== AUTOSAVE FUNCTIONS =====
        async function saveAutosave() {
            // Only DM can trigger autosave when connected to server
            if (!isDM || !isConnected) {
                return;
            }

            try {
                const data = {
                    characters: characters.map(char => ({
                        name: char.name,
                        type: char.type,
                        maxHp: char.maxHp,
                        currentHp: char.currentHp,
                        tempHp: char.tempHp,
                        ac: char.ac,
                        initBonus: char.initBonus,
                        maxPower: char.maxPower,
                        currentPower: char.currentPower,
                        powerName: char.powerName,
                        effects: char.effects,
                        initiative: char.initiative,
                        monsterData: char.monsterData,
                        groupId: char.groupId,
                        groupName: char.groupName,
                        revealedToPlayers: char.revealedToPlayers,
                        spellcasterLevel: char.spellcasterLevel,
                        spellSlots: char.spellSlots,
                        customFeatures: char.customFeatures,
                        hitDice: char.hitDice
                    })),
                    combatState: combatState,
                    monsterDatabase: monsterDatabase,
                    timestamp: new Date().toISOString()
                };

                const response = await fetch('/api/autosave', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });

                const result = await response.json();
                if (result.success) {
                    console.log('‚úÖ Autosave created:', new Date().toLocaleTimeString());
                } else {
                    console.error('‚ùå Autosave failed:', result.error);
                }
            } catch (error) {
                console.error('‚ùå Error creating autosave:', error);
            }
        }

        async function loadAutosave() {
            try {
                const response = await fetch('/api/autosave');
                const result = await response.json();

                if (result.success && result.data) {
                    const data = result.data;

                    if (data.characters && Array.isArray(data.characters)) {
                        characters = data.characters.map(char => ({
                            ...char,
                            id: Date.now() + Math.random(),
                            tempHp: char.tempHp || 0,
                            ac: char.ac || 10,
                            effects: char.effects || [],
                            initiative: char.initiative || null,
                            groupId: char.groupId || null,
                            groupName: char.groupName || null,
                            revealedToPlayers: char.revealedToPlayers !== undefined ? char.revealedToPlayers : (char.type === 'player'),
                            spellcasterLevel: char.spellcasterLevel || 0,
                            spellSlots: char.spellSlots || {},
                            customFeatures: char.customFeatures || [],
                            hitDice: char.hitDice || { max: 0, current: 0 }
                        }));

                        if (data.combatState) {
                            combatState = data.combatState;
                        }

                        if (data.monsterDatabase) {
                            monsterDatabase = data.monsterDatabase;
                            saveMonsterDatabaseToStorage();
                            renderMonsterList();
                        }

                        renderCharacters();

                        // Restore combat UI state
                        if (combatState.active) {
                            document.getElementById('startBtn').classList.add('hidden');
                            document.getElementById('prevBtn').classList.remove('hidden');
                            document.getElementById('nextBtn').classList.remove('hidden');
                            document.getElementById('endBtn').classList.remove('hidden');
                            document.getElementById('closeBtn').classList.remove('hidden');
                            document.getElementById('saveCombatBtn').style.display = 'inline-block';
                            updateInitiativeDisplay();
                        }

                        // Sync to server after loading autosave
                        syncToServer();

                        console.log('‚úÖ Autosave loaded successfully from:', new Date(data.timestamp).toLocaleString());
                        return true;
                    }
                } else {
                    console.log('‚ÑπÔ∏è No autosave found');
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Error loading autosave:', error);
                return false;
            }
        }

        // History/Undo syst√©m
        function saveState() {
            const state = {
                characters: JSON.parse(JSON.stringify(characters)),
                combatState: JSON.parse(JSON.stringify(combatState))
            };
            historyStack.push(state);
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
            }
            // Vymazat redo stack kdy≈æ udƒõl√°me novou akci
            redoStack = [];
        }

        function undo() {
            if (historyStack.length === 0) {
                alert('Nelze vr√°tit zpƒõt - ≈æ√°dn√° historie zmƒõn!');
                return;
            }

            // Ulo≈æ souƒçasn√Ω stav do redo stacku
            const currentState = {
                characters: JSON.parse(JSON.stringify(characters)),
                combatState: JSON.parse(JSON.stringify(combatState))
            };
            redoStack.push(currentState);
            if (redoStack.length > MAX_HISTORY) {
                redoStack.shift();
            }

            // Obnov p≈ôedchoz√≠ stav
            const previousState = historyStack.pop();
            characters = JSON.parse(JSON.stringify(previousState.characters));
            combatState = JSON.parse(JSON.stringify(previousState.combatState));

            // Obnovit UI podle stavu
            renderCharacters();
            if (combatState.active) {
                document.getElementById('startBtn').classList.add('hidden');
                document.getElementById('prevBtn').classList.remove('hidden');
                document.getElementById('nextBtn').classList.remove('hidden');
                document.getElementById('endBtn').classList.remove('hidden');
                document.getElementById('closeBtn').classList.remove('hidden');
                document.getElementById('saveCombatBtn').style.display = 'inline-block';
                updateInitiativeDisplay();
            } else {
                document.getElementById('startBtn').classList.remove('hidden');
                document.getElementById('prevBtn').classList.add('hidden');
                document.getElementById('nextBtn').classList.add('hidden');
                document.getElementById('endBtn').classList.add('hidden');
                document.getElementById('closeBtn').classList.add('hidden');
                document.getElementById('saveCombatBtn').style.display = 'none';
                document.getElementById('initiativeOrder').classList.add('hidden');
            }

            // Synchronizovat se serverem
            syncToServer();
        }

        function redo() {
            if (redoStack.length === 0) {
                alert('Nelze posunout dop≈ôedu - ≈æ√°dn√° historie!');
                return;
            }

            // Ulo≈æ souƒçasn√Ω stav do history stacku
            const currentState = {
                characters: JSON.parse(JSON.stringify(characters)),
                combatState: JSON.parse(JSON.stringify(combatState))
            };
            historyStack.push(currentState);
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
            }

            // Obnov n√°sleduj√≠c√≠ stav
            const nextState = redoStack.pop();
            characters = JSON.parse(JSON.stringify(nextState.characters));
            combatState = JSON.parse(JSON.stringify(nextState.combatState));

            // Obnovit UI podle stavu
            renderCharacters();
            if (combatState.active) {
                document.getElementById('startBtn').classList.add('hidden');
                document.getElementById('prevBtn').classList.remove('hidden');
                document.getElementById('nextBtn').classList.remove('hidden');
                document.getElementById('endBtn').classList.remove('hidden');
                document.getElementById('closeBtn').classList.remove('hidden');
                document.getElementById('saveCombatBtn').style.display = 'inline-block';
                updateInitiativeDisplay();
            } else {
                document.getElementById('startBtn').classList.remove('hidden');
                document.getElementById('prevBtn').classList.add('hidden');
                document.getElementById('nextBtn').classList.add('hidden');
                document.getElementById('endBtn').classList.add('hidden');
                document.getElementById('closeBtn').classList.add('hidden');
                document.getElementById('saveCombatBtn').style.display = 'none';
                document.getElementById('initiativeOrder').classList.add('hidden');
            }

            // Synchronizovat se serverem
            syncToServer();
        }

        // Drag and Drop funkce
        function handleDragStart(e, index) {
            if (!combatState.active) return;
            saveState();
            draggedCharacterIndex = index;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(e) {
            if (!combatState.active || draggedCharacterIndex === null) return;
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e, index) {
            if (!combatState.active || draggedCharacterIndex === null) return;
            const card = e.currentTarget;
            card.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            if (!combatState.active) return;
            const card = e.currentTarget;
            card.classList.remove('drag-over');
        }

        function handleDrop(e, dropIndex) {
            if (!combatState.active || draggedCharacterIndex === null) return;
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            if (draggedCharacterIndex === dropIndex) return;

            // Uchov√°n√≠ ID aktu√°ln√≠ postavy na tahu
            const currentCharId = characters[combatState.currentTurn].id;

            // P≈ôesu≈à postavu
            const draggedChar = characters[draggedCharacterIndex];
            characters.splice(draggedCharacterIndex, 1);
            characters.splice(dropIndex, 0, draggedChar);

            // Najdi novou pozici aktu√°ln√≠ postavy na tahu
            const newCurrentIndex = characters.findIndex(char => char.id === currentCharId);
            combatState.currentTurn = newCurrentIndex;

            // P≈ôepoƒç√≠tej playedThisRound indexy
            const newPlayedThisRound = [];
            for (let i = 0; i < newCurrentIndex; i++) {
                newPlayedThisRound.push(i);
            }
            combatState.playedThisRound = newPlayedThisRound;

            updateInitiativeDisplay();
            renderCharacters();
            syncToServer();
            draggedCharacterIndex = null;
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.drag-over').forEach(card => {
                card.classList.remove('drag-over');
            });
            draggedCharacterIndex = null;
        }

        function renderCharacters() {
            const listDiv = document.getElementById('characterList');
            const visibleChars = getVisibleCharacters();

            listDiv.innerHTML = visibleChars.map((char) => {
                // Najdi skuteƒçn√Ω index v p≈Øvodn√≠m characters array
                const index = characters.findIndex(c => c.id === char.id);
                const isActive = combatState.active && index === combatState.currentTurn;
                const hasPlayed = combatState.active && combatState.playedThisRound.includes(index);
                const hpPercentage = (char.currentHp / char.maxHp) * 100;
                
                return `
                    <div class="character-card ${isActive ? 'active' : ''} ${hasPlayed ? 'played' : ''}"
                         draggable="${combatState.active ? 'true' : 'false'}"
                         data-index="${index}"
                         ondragstart="handleDragStart(event, ${index})"
                         ondragover="handleDragOver(event)"
                         ondragenter="handleDragEnter(event, ${index})"
                         ondragleave="handleDragLeave(event)"
                         ondrop="handleDrop(event, ${index})"
                         ondragend="handleDragEnd(event)"
                         style="${combatState.active ? 'cursor: move;' : ''}"
                    >
                        <div class="character-header">
                            <span class="character-name" onclick="openEffectModal(${char.id})">${char.name}</span>
                            <div>
                                <span class="character-type">${char.type === 'player' ? 'Hr√°ƒç' : 'Monstrum'}</span>
                                ${char.groupName ? `<span class="group-badge" style="background: ${getGroupColor(char.groupId)}">Group ${char.groupName}</span>` : ''}
                            </div>
                            ${isDM ? `
                            <div>
                                ${char.groupName ? `<button onclick="unlinkFromGroup(${char.id})" class="control-btn" style="background: #95a5a6;" title="Oddƒõlit od skupiny">üîó</button>` : ''}
                                ${char.type === 'monster' ? `<button onclick="duplicateMonster(${char.id})" class="btn-success control-btn">‚ûï</button>` : ''}
                                ${char.type === 'player' ? `<button onclick="openCharacterSheet(${char.id})" class="btn-purple control-btn" title="Character Sheet">üìã</button>` : ''}
                                ${char.type === 'monster' && char.monsterAbilities && char.monsterAbilities.enabled ? `<button onclick="openMonsterSheet(${char.id})" class="btn-purple control-btn" title="Monster Abilities">üëπ</button>` : ''}
                                <button onclick="removeCharacter(${char.id})" class="btn-danger control-btn">‚ùå</button>
                            </div>
                            ` : ''}
                        </div>
                        
                        <div class="character-stats">
                            <div class="stat-group">
                                <div class="stat-label">HP</div>
                                <div class="stat-value">${
                                    (isPlayer && char.type === 'monster')
                                        ? getMonsterHealthIndicator(char.currentHp, char.maxHp)
                                        : `${char.currentHp}/${char.maxHp}`
                                }</div>
                            </div>
                            <div class="stat-group">
                                <div class="stat-label">Doƒçasn√© HP</div>
                                <div class="stat-value">${char.tempHp}</div>
                            </div>
                            <div class="stat-group">
                                <div class="stat-label">AC</div>
                                <div class="stat-value">${char.ac || 10}</div>
                            </div>
                            <div class="stat-group">
                                <div class="stat-label">Iniciativa</div>
                                <div class="stat-value">
                                    <input type="number" value="${char.initiative || ''}" onchange="setInitiative(${char.id}, this.value)" style="width: 60px; text-align: center;">
                                    <span class="init-bonus">(${char.initBonus >= 0 ? '+' : ''}${char.initBonus})</span>
                                </div>
                            </div>
                            ${(char.type === 'monster' && isDM) ? `
                            <div class="stat-group">
                                <div class="stat-label">${char.powerName || 'Power'}</div>
                                <div class="stat-value">${char.currentPower}/${char.maxPower}</div>
                            </div>
                            ` : ''}
                        </div>

                        ${(isDM || char.type === 'player') ? `
                        <div class="hp-bar">
                            <div class="hp-fill ${getHpBarClass(char.currentHp, char.maxHp)}" style="width: ${hpPercentage}%"></div>
                        </div>
                        ` : ''}

                        <div class="effects">
                            ${char.effects.map((effect, idx) => `<span class="effect-tag ${getEffectClass(effect)}" title="${getEffectDescription(effect)}" onclick="removeEffectFromCharacter(${char.id}, ${idx})">${effectToString(effect)}</span>`).join('')}
                        </div>

                        ${(char.monsterData && isDM) ? `
                        <div>
                            <span class="statblock-toggle" onclick="toggleStatblock(${char.id})">üìñ Zobrazit statblock</span>
                            <div id="statblock-${char.id}" class="statblock-panel">
                                <div style="margin-bottom: 15px; font-size: 0.9em;">
                                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; text-align: center; background: #ecf0f1; padding: 10px; border-radius: 5px;">
                                        <div><strong>STR</strong><br>${char.monsterData.stats.str} (${Math.floor((char.monsterData.stats.str - 10) / 2) >= 0 ? '+' : ''}${Math.floor((char.monsterData.stats.str - 10) / 2)})</div>
                                        <div><strong>DEX</strong><br>${char.monsterData.stats.dex} (${Math.floor((char.monsterData.stats.dex - 10) / 2) >= 0 ? '+' : ''}${Math.floor((char.monsterData.stats.dex - 10) / 2)})</div>
                                        <div><strong>CON</strong><br>${char.monsterData.stats.con} (${Math.floor((char.monsterData.stats.con - 10) / 2) >= 0 ? '+' : ''}${Math.floor((char.monsterData.stats.con - 10) / 2)})</div>
                                        <div><strong>INT</strong><br>${char.monsterData.stats.int} (${Math.floor((char.monsterData.stats.int - 10) / 2) >= 0 ? '+' : ''}${Math.floor((char.monsterData.stats.int - 10) / 2)})</div>
                                        <div><strong>WIS</strong><br>${char.monsterData.stats.wis} (${Math.floor((char.monsterData.stats.wis - 10) / 2) >= 0 ? '+' : ''}${Math.floor((char.monsterData.stats.wis - 10) / 2)})</div>
                                        <div><strong>CHA</strong><br>${char.monsterData.stats.cha} (${Math.floor((char.monsterData.stats.cha - 10) / 2) >= 0 ? '+' : ''}${Math.floor((char.monsterData.stats.cha - 10) / 2)})</div>
                                    </div>
                                    ${char.monsterData.savingThrows ? `<p style="margin-top: 8px;"><strong>Saving Throws:</strong> ${char.monsterData.savingThrows}</p>` : ''}
                                    ${char.monsterData.resistances ? `<p style="margin-top: 5px;"><strong>Resistances:</strong> ${char.monsterData.resistances}</p>` : ''}
                                    ${char.monsterData.immunities ? `<p style="margin-top: 5px;"><strong>Immunities:</strong> ${char.monsterData.immunities}</p>` : ''}
                                </div>
                                ${char.monsterData.defensiveTraits && char.monsterData.defensiveTraits.length > 0 ? `
                                <h5>Defensive Traits:</h5>
                                ${char.monsterData.defensiveTraits.map(t => `<div style="margin-bottom: 10px;">${markdownToHtml(t)}</div>`).join('')}
                                ` : ''}
                                ${char.monsterData.traits && char.monsterData.traits.length > 0 ? `
                                <h5>Traits:</h5>
                                ${char.monsterData.traits.map(t => `<div style="margin-bottom: 10px;">${markdownToHtml(t)}</div>`).join('')}
                                ` : ''}
                                ${char.monsterData.actions && char.monsterData.actions.length > 0 ? `
                                <h5>Actions:</h5>
                                ${char.monsterData.actions.map(a => `<div style="margin-bottom: 10px;">${markdownToHtml(a)}</div>`).join('')}
                                ` : ''}
                                ${char.monsterData.bonusActions && char.monsterData.bonusActions.length > 0 ? `
                                <h5>Bonus Actions:</h5>
                                ${char.monsterData.bonusActions.map(a => `<div style="margin-bottom: 10px;">${markdownToHtml(a)}</div>`).join('')}
                                ` : ''}
                                ${char.monsterData.reactions && char.monsterData.reactions.length > 0 ? `
                                <h5>Reactions:</h5>
                                ${char.monsterData.reactions.map(r => `<div style="margin-bottom: 10px;">${markdownToHtml(r)}</div>`).join('')}
                                ` : ''}
                                ${char.monsterData.legendaryActions && char.monsterData.legendaryActions.length > 0 ? `
                                <h5>Legendary Actions:</h5>
                                ${char.monsterData.legendaryActions.map(a => `<div style="margin-bottom: 10px;">${markdownToHtml(a)}</div>`).join('')}
                                ` : ''}
                                ${char.monsterData.mythicActions && char.monsterData.mythicActions.length > 0 ? `
                                <h5>Mythic Actions:</h5>
                                ${char.monsterData.mythicActions.map(a => `<div style="margin-bottom: 10px;">${markdownToHtml(a)}</div>`).join('')}
                                ` : ''}
                                ${char.monsterData.lairActions && char.monsterData.lairActions.length > 0 ? `
                                <h5>Lair Actions:</h5>
                                ${char.monsterData.lairActions.map(a => `<div style="margin-bottom: 10px;">${markdownToHtml(a)}</div>`).join('')}
                                ` : ''}
                            </div>
                        </div>
                        ` : ''}

                        ${(isDM || char.type === 'player') ? `
                        <div class="controls">
                            <button onclick="updateHp(${char.id}, -1)" class="btn-danger control-btn">HP -1</button>
                            <button onclick="updateHp(${char.id}, -10)" class="btn-danger control-btn">HP -10</button>
                            <button onclick="updateHp(${char.id}, 1)" class="btn-success control-btn">HP +1</button>
                            <button onclick="updateHp(${char.id}, 10)" class="btn-success control-btn">HP +10</button>
                        </div>

                        <div class="custom-hp-controls">
                            <input type="number" data-damage-id="${char.id}" class="custom-input" placeholder="Po≈°kozen√≠">
                            <button onclick="applyCustomDamage(${char.id})" class="btn-danger control-btn">Aplikovat</button>
                            <input type="number" data-healing-id="${char.id}" class="custom-input" placeholder="L√©ƒçen√≠">
                            <button onclick="applyCustomHealing(${char.id})" class="btn-success control-btn">Aplikovat</button>
                            <input type="number" data-temp-id="${char.id}" class="custom-input" placeholder="Doƒçasn√© HP">
                            <button onclick="setTempHp(${char.id})" class="btn-warning control-btn">Nastavit</button>
                            <input type="number" data-maxhp-id="${char.id}" class="custom-input" placeholder="Zmƒõna max HP">
                            <button onclick="applyMaxHpChange(${char.id})" class="btn-purple control-btn">Aplikovat</button>
                        </div>
                        ` : ''}

                        ${(char.type === 'monster' && isDM) ? `
                        <div class="power-controls">
                            <button onclick="updatePower(${char.id}, -1)" class="btn-danger control-btn">${char.powerName || 'Power'} -1</button>
                            <input type="number" value="${char.currentPower}" onchange="setPower(${char.id}, this.value)" class="power-input">
                            <button onclick="updatePower(${char.id}, 1)" class="btn-success control-btn">${char.powerName || 'Power'} +1</button>
                        </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
            saveToLocalStorage();
        }

        function saveData() {
            const data = {
                characters: characters.map(char => ({
                    name: char.name,
                    type: char.type,
                    maxHp: char.maxHp,
                    currentHp: char.currentHp,
                    tempHp: char.tempHp,
                    ac: char.ac,
                    initBonus: char.initBonus,
                    maxPower: char.maxPower,
                    currentPower: char.currentPower,
                    powerName: char.powerName,
                    effects: char.effects,
                    monsterData: char.monsterData,
                    groupId: char.groupId,
                    groupName: char.groupName,
                    // Spell tracking properties
                    spellcasterLevel: char.spellcasterLevel,
                    spellSlots: char.spellSlots,
                    customFeatures: char.customFeatures,
                    hitDice: char.hitDice
                })),
                timestamp: new Date().toISOString()
            };

            const defaultName = `dnd-tracker-${new Date().toISOString().split('T')[0]}`;
            openFileNameModal('üíæ Ulo≈æit data postav', defaultName, data, downloadJsonFile);
        }

        function saveCombatState() {
            const data = {
                characters: characters.map(char => ({
                    name: char.name,
                    type: char.type,
                    maxHp: char.maxHp,
                    currentHp: char.currentHp,
                    tempHp: char.tempHp,
                    ac: char.ac,
                    initBonus: char.initBonus,
                    initiative: char.initiative,
                    maxPower: char.maxPower,
                    currentPower: char.currentPower,
                    powerName: char.powerName,
                    effects: char.effects,
                    monsterData: char.monsterData,
                    groupId: char.groupId,
                    groupName: char.groupName,
                    // Spell tracking properties
                    spellcasterLevel: char.spellcasterLevel,
                    spellSlots: char.spellSlots,
                    customFeatures: char.customFeatures,
                    hitDice: char.hitDice
                })),
                combatState: {
                    active: combatState.active,
                    currentTurn: combatState.currentTurn,
                    round: combatState.round,
                    playedThisRound: combatState.playedThisRound
                },
                timestamp: new Date().toISOString()
            };

            const defaultName = `dnd-combat-${new Date().toISOString().split('T')[0]}`;
            openFileNameModal('üíæ Ulo≈æit stav boje', defaultName, data, downloadJsonFile);
        }

        function loadData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.characters && Array.isArray(data.characters)) {
                        // Kumulativn√≠ naƒç√≠t√°n√≠ - p≈ôidej nov√© postavy k existuj√≠c√≠m
                        const newCharacters = data.characters.map(char => ({
                            ...char,
                            id: Date.now() + Math.random(),
                            initiative: null,
                            tempHp: char.tempHp || 0,
                            ac: char.ac || 10,
                            effects: char.effects || [],
                            groupId: char.groupId || null,
                            groupName: char.groupName || null,
                            // Spell tracking properties - zachovat pokud jsou v importu, jinak default
                            spellcasterLevel: char.spellcasterLevel || 0,
                            spellSlots: char.spellSlots || {},
                            customFeatures: char.customFeatures || [],
                            hitDice: char.hitDice || { max: 0, current: 0 }
                        }));

                        characters = characters.concat(newCharacters);
                        renderCharacters();
                        populateSpellCharacterSelect(); // Refresh spell page character select
                        syncToServer();
                        alert(`√öspƒõ≈°nƒõ naƒçteno ${newCharacters.length} postav!`);
                    } else {
                        alert('Neplatn√Ω form√°t souboru!');
                    }
                } catch (error) {
                    alert('Chyba p≈ôi naƒç√≠t√°n√≠ souboru!');
                }
            };
            reader.readAsText(file);
        }

        function loadCombatState(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.characters && Array.isArray(data.characters) && data.combatState) {
                        // P≈ôepsat V≈†E - kompletn√≠ naƒçten√≠ stavu boje
                        characters = data.characters.map(char => ({
                            ...char,
                            id: Date.now() + Math.random(),
                            tempHp: char.tempHp || 0,
                            ac: char.ac || 10,
                            effects: char.effects || [],
                            initiative: char.initiative || null,
                            groupId: char.groupId || null,
                            groupName: char.groupName || null,
                            // Backward compatibility: pokud nen√≠ revealedToPlayers, nastav podle typu
                            revealedToPlayers: char.revealedToPlayers !== undefined ? char.revealedToPlayers : (char.type === 'player'),
                            // Spell tracking properties
                            spellcasterLevel: char.spellcasterLevel || 0,
                            spellSlots: char.spellSlots || {},
                            customFeatures: char.customFeatures || [],
                            hitDice: char.hitDice || { max: 0, current: 0 }
                        }));

                        // Obnovit stav boje
                        combatState = data.combatState;

                        // Vyƒçistit historii (nov√Ω zaƒç√°tek)
                        historyStack = [];
                        redoStack = [];

                        renderCharacters();

                        // Obnovit UI podle stavu boje
                        if (combatState.active) {
                            document.getElementById('startBtn').classList.add('hidden');
                            document.getElementById('prevBtn').classList.remove('hidden');
                            document.getElementById('nextBtn').classList.remove('hidden');
                            document.getElementById('endBtn').classList.remove('hidden');
                            document.getElementById('closeBtn').classList.remove('hidden');
                            document.getElementById('saveCombatBtn').style.display = 'inline-block';
                            updateInitiativeDisplay();
                            alert(`Stav boje naƒçten! Kolo ${combatState.round}, na tahu: ${characters[combatState.currentTurn]?.name}`);
                        } else {
                            document.getElementById('startBtn').classList.remove('hidden');
                            document.getElementById('prevBtn').classList.add('hidden');
                            document.getElementById('nextBtn').classList.add('hidden');
                            document.getElementById('endBtn').classList.add('hidden');
                            document.getElementById('closeBtn').classList.add('hidden');
                            document.getElementById('saveCombatBtn').style.display = 'none';
                            document.getElementById('initiativeOrder').classList.add('hidden');
                            alert(`Naƒçteno ${characters.length} postav!`);
                        }
                    } else {
                        alert('Neplatn√Ω form√°t souboru stavu boje!');
                    }
                } catch (error) {
                    console.error('Error loading combat state:', error);
                    alert('Chyba p≈ôi naƒç√≠t√°n√≠ stavu boje!');
                }
            };
            reader.readAsText(file);

            // Reset file input
            event.target.value = '';
        }

        function clearAll() {
            if (confirm('Opravdu chcete vymazat v≈°echna data?')) {
                characters = [];
                endCombat();
                renderCharacters();
            }
        }

        // Zav≈ôen√≠ modalu p≈ôi kliknut√≠ mimo nƒõj
        window.onclick = function(event) {
            const modal = document.getElementById('effectModal');
            if (event.target === modal) {
                closeEffectModal();
            }
        }

        // Ulo≈æen√≠ p≈ôed zav≈ôen√≠m str√°nky
        window.addEventListener('beforeunload', function(e) {
            saveToLocalStorage();
        });

        // Kl√°vesov√© zkratky
        document.addEventListener('keydown', function(e) {
            // Ignoruj zkratky pokud je otev≈ôen√Ω modal nebo pokud p√≠≈°eme do inputu
            if (document.getElementById('effectModal').style.display === 'block' ||
                e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            switch(e.key) {
                case ' ': // Space
                case 'PageUp':
                    if (combatState.active) {
                        e.preventDefault();
                        nextTurn();
                    }
                    break;
                case 'PageDown':
                    if (combatState.active) {
                        e.preventDefault();
                        previousTurn();
                    }
                    break;
                case 'Backspace':
                    e.preventDefault();
                    if (e.shiftKey) {
                        redo(); // Shift+Backspace = Redo
                    } else {
                        undo(); // Backspace = Undo
                    }
                    break;
            }
        });

        // ===== PLAYER MODE UI SETUP =====
        function setupPlayerMode() {
            // Update mode indicator
            document.getElementById('viewMode').textContent = isPlayer ? 'üë• Player View' : 'üé≤ DM View';

            if (isPlayer) {
                // Hide DM-only sections
                const sectionsToHide = [
                    'dataManagementSection',
                    'addCharacterSection',
                    'monsterDatabaseSection'
                ];

                sectionsToHide.forEach(id => {
                    const section = document.getElementById(id);
                    if (section) section.style.display = 'none';
                });

                // Disable auto-save for players (server is source of truth)
                if (autoSaveInterval) {
                    clearInterval(autoSaveInterval);
                }
            }
        }

        // Inicializace
        if (isDM) {
            // Try to load autosave first, fallback to localStorage
            loadAutosave().then((autosaveLoaded) => {
                if (!autosaveLoaded) {
                    // No autosave found, load from localStorage
                    loadFromLocalStorage();
                    loadMonsterDatabaseFromStorage();
                }
                // Render characters after loading
                if (characters.length === 0) {
                    renderCharacters();
                }
            });

            // Auto-save ka≈æd√Ωch 30 sekund (DM only) - using localStorage
            autoSaveInterval = setInterval(saveToLocalStorage, 30000);
        } else {
            // Players don't use autosave
            if (characters.length === 0) {
                renderCharacters();
            }
        }

        // ===== SPELL TRACKING FUNCTIONS =====

        // D&D 5e Spell Slots Table (with Epic levels 21-30)
        const SPELL_SLOTS_TABLE = {
            1: [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            2: [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            3: [4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            4: [4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            5: [4, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            6: [4, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            7: [4, 3, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0],
            8: [4, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0],
            9: [4, 3, 3, 3, 1, 0, 0, 0, 0, 0, 0, 0],
            10: [4, 3, 3, 3, 2, 0, 0, 0, 0, 0, 0, 0],
            11: [4, 3, 3, 3, 2, 1, 0, 0, 0, 0, 0, 0],
            12: [4, 3, 3, 3, 2, 1, 0, 0, 0, 0, 0, 0],
            13: [4, 3, 3, 3, 2, 1, 1, 0, 0, 0, 0, 0],
            14: [4, 3, 3, 3, 2, 1, 1, 0, 0, 0, 0, 0],
            15: [4, 3, 3, 3, 2, 1, 1, 1, 0, 0, 0, 0],
            16: [4, 3, 3, 3, 2, 1, 1, 1, 0, 0, 0, 0],
            17: [4, 3, 3, 3, 2, 1, 1, 1, 1, 0, 0, 0],
            18: [4, 3, 3, 3, 3, 1, 1, 1, 1, 0, 0, 0],
            19: [4, 3, 3, 3, 3, 2, 1, 1, 1, 0, 0, 0],
            20: [4, 3, 3, 3, 3, 2, 2, 1, 1, 0, 0, 0],
            // Epic levels 21-30
            21: [4, 3, 3, 3, 3, 2, 2, 1, 1, 2, 0, 0],  // 2x Epic 1
            22: [4, 3, 3, 3, 3, 2, 2, 1, 1, 3, 0, 0],  // 3x Epic 1
            23: [4, 3, 3, 3, 3, 2, 2, 1, 1, 3, 1, 0],  // 3x Epic 1, 1x Epic 2
            24: [4, 3, 3, 3, 3, 2, 2, 1, 1, 3, 2, 0],  // 3x Epic 1, 2x Epic 2
            25: [4, 3, 3, 3, 3, 2, 2, 1, 1, 3, 2, 0],  // 3x Epic 1, 2x Epic 2
            26: [4, 3, 3, 3, 3, 2, 2, 1, 1, 3, 2, 1],  // 3x Epic 1, 2x Epic 2, 1x Epic 3
            27: [4, 3, 3, 3, 3, 2, 2, 1, 1, 3, 2, 1],  // 3x Epic 1, 2x Epic 2, 1x Epic 3
            28: [4, 3, 3, 3, 3, 2, 2, 1, 1, 3, 2, 1],  // 3x Epic 1, 2x Epic 2, 1x Epic 3
            29: [4, 3, 3, 3, 3, 2, 2, 1, 1, 3, 2, 1],  // 3x Epic 1, 2x Epic 2, 1x Epic 3
            30: [4, 3, 3, 3, 3, 2, 2, 1, 1, 3, 2, 1]   // 3x Epic 1, 2x Epic 2, 1x Epic 3
        };

        let currentSpellCharacterId = null;
        let currentMonsterCharacterId = null;

        // Page Switching
        function switchPage(pageName) {
            // Hide all pages
            document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
            document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));

            // Show selected page
            if (pageName === 'combat') {
                document.getElementById('combatPage').classList.add('active');
                document.querySelectorAll('.nav-btn')[0].classList.add('active');
            } else if (pageName === 'spells') {
                document.getElementById('spellsPage').classList.add('active');
                document.querySelectorAll('.nav-btn')[1].classList.add('active');
                populateSpellCharacterSelect();
            } else if (pageName === 'monsters') {
                document.getElementById('monstersPage').classList.add('active');
                document.querySelectorAll('.nav-btn')[2].classList.add('active');
                populateMonsterCharacterSelect();
            }
        }

        // Populate character select dropdown with players only
        function populateSpellCharacterSelect() {
            const select = document.getElementById('spellCharacterSelect');
            const playerCharacters = characters.filter(char => char.type === 'player');

            select.innerHTML = '<option value="">-- Vyberte postavu --</option>';
            playerCharacters.forEach(char => {
                const option = document.createElement('option');
                option.value = char.id;
                option.textContent = char.name;
                select.appendChild(option);
            });

            // If current character is still selected, keep it
            if (currentSpellCharacterId) {
                select.value = currentSpellCharacterId;
                if (select.value !== currentSpellCharacterId) {
                    // Character was removed, reset
                    currentSpellCharacterId = null;
                    document.getElementById('editSpellCharBtn').style.display = 'none';
                    showEmptySpellState();
                }
            }
        }

        // Load selected character
        function loadSpellCharacter() {
            const select = document.getElementById('spellCharacterSelect');
            const characterId = parseFloat(select.value);

            if (!characterId) {
                currentSpellCharacterId = null;
                document.getElementById('editSpellCharBtn').style.display = 'none';
                showEmptySpellState();
                return;
            }

            currentSpellCharacterId = characterId;
            document.getElementById('editSpellCharBtn').style.display = 'inline-block';
            renderSpellTracking();
        }

        // ===== MONSTER ABILITIES TRACKING FUNCTIONS =====

        // Populate monster character select dropdown with monsters only
        function populateMonsterCharacterSelect() {
            const select = document.getElementById('monsterCharacterSelect');
            const monsterCharacters = characters.filter(char => char.type === 'monster');

            select.innerHTML = '<option value="">-- Vyberte monstrum --</option>';
            monsterCharacters.forEach(char => {
                const option = document.createElement('option');
                option.value = char.id;
                option.textContent = char.name;
                select.appendChild(option);
            });

            // If current monster is still selected, keep it
            if (currentMonsterCharacterId) {
                select.value = currentMonsterCharacterId;
                if (select.value !== currentMonsterCharacterId) {
                    // Monster was removed, reset
                    currentMonsterCharacterId = null;
                    showEmptyMonsterState();
                }
            }
        }

        // Load selected monster
        function loadMonsterCharacter() {
            const select = document.getElementById('monsterCharacterSelect');
            const characterId = parseFloat(select.value);

            if (!characterId) {
                currentMonsterCharacterId = null;
                showEmptyMonsterState();
                return;
            }

            currentMonsterCharacterId = characterId;
            renderMonsterAbilities();
        }

        function showEmptyMonsterState() {
            document.getElementById('monsterAbilityContent').innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">üëπ</div>
                    <h3>Vyberte monstrum</h3>
                    <p>Zvolte monstrum ze seznamu v√Ω≈°e pro spr√°vu abilities a spellcastingu</p>
                </div>
            `;
        }

        function renderMonsterAbilities() {
            const monster = characters.find(c => c.id === currentMonsterCharacterId);
            if (!monster) {
                showEmptyMonsterState();
                return;
            }

            // Initialize monsterAbilities if doesn't exist
            if (!monster.monsterAbilities) {
                monster.monsterAbilities = {
                    enabled: false,
                    spellcastingType: 'none', // 'none', 'per-day', or 'level-based'
                    spellcastingLevel: 0,
                    spellSlots: {},
                    perDaySpells: [], // For per-day spellcasting
                    legendaryActions: {
                        enabled: false,
                        max: 3,
                        used: 0
                    },
                    customFeatures: []
                };
            }

            let html = `
                <div style="margin-bottom: 20px;">
                    <h3 style="color: #3498db;">üëπ ${monster.name}</h3>
                    <p style="color: #7f8c8d; font-size: 0.9em;">Ability Tracker pro toto monstrum</p>
                </div>
            `;

            const abilities = monster.monsterAbilities;

            // Power System Section (if monster has power)
            if (monster.maxPower && monster.maxPower > 0) {
                const currentPower = monster.currentPower || 0;
                const powerPercent = (currentPower / monster.maxPower) * 100;
                const powerColor = powerPercent > 50 ? '#3498db' : powerPercent > 25 ? '#f39c12' : '#e74c3c';

                html += `
                    <div style="margin: 20px 0; padding: 15px; background: #e3f2fd; border-radius: 8px;">
                        <h4 style="color: #1976d2; margin-bottom: 10px;">‚ö° ${monster.powerName || 'Power'}</h4>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <button class="control-btn btn-danger" onclick="adjustMonsterPower(-1)">-1</button>
                            <button class="control-btn btn-danger" onclick="adjustMonsterPower(-5)">-5</button>
                            <div style="flex: 1; min-width: 200px;">
                                <div class="hp-bar">
                                    <div class="hp-fill" style="width: ${powerPercent}%; background: ${powerColor};"></div>
                                </div>
                                <div style="text-align: center; margin-top: 5px; font-weight: bold;">
                                    ${currentPower} / ${monster.maxPower}
                                </div>
                            </div>
                            <button class="control-btn btn-success" onclick="adjustMonsterPower(5)">+5</button>
                            <button class="control-btn btn-success" onclick="adjustMonsterPower(1)">+1</button>
                        </div>
                    </div>
                `;
            }

            // Legendary Actions Section
            if (abilities.legendaryActions && abilities.legendaryActions.enabled) {
                html += `
                    <div style="margin: 20px 0; padding: 15px; background: #fff3cd; border-radius: 8px;">
                        <h4 style="color: #856404; margin-bottom: 10px;">‚ö° Legendary Actions</h4>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span>Pou≈æito: ${abilities.legendaryActions.used} / ${abilities.legendaryActions.max}</span>
                            <button class="control-btn btn-success" onclick="changeLegendaryActions(-1)">-1</button>
                            <button class="control-btn btn-danger" onclick="changeLegendaryActions(1)">+1</button>
                        </div>
                        <small style="color: #856404; display: block; margin-top: 5px;">
                            Automaticky se resetuje na zaƒç√°tku tahu monstra
                        </small>
                    </div>
                `;
            }

            // Spellcasting Section
            if (abilities.spellcastingType !== 'none') {
                html += `<h3 style="margin: 20px 0;">‚ú® Spellcasting</h3>`;

                if (abilities.spellcastingType === 'level-based' && abilities.spellcastingLevel > 0) {
                    // Standard spell slots (like players)
                    const slotsArray = SPELL_SLOTS_TABLE[abilities.spellcastingLevel] || [];
                    html += `<div class="spell-slots-grid">`;

                    for (let level = 1; level <= 9; level++) {
                        const maxSlots = abilities.spellSlots[level]?.max || slotsArray[level - 1] || 0;
                        if (maxSlots > 0) {
                            const used = abilities.spellSlots[level]?.used || 0;
                            html += `
                                <div class="spell-level-container">
                                    <div class="spell-level-header">
                                        <span class="spell-level-label">Level ${level}</span>
                                        <input type="number" min="0" value="${maxSlots}"
                                               onchange="updateMonsterSpellSlotMax(${level}, this.value)"
                                               style="width: 50px; padding: 3px;" title="Upravit poƒçet slot≈Ø">
                                    </div>
                                    <div class="spell-slots">
                            `;

                            for (let i = 0; i < maxSlots; i++) {
                                const slotUsed = i < used;
                                html += `<div class="spell-slot ${slotUsed ? 'used' : ''}"
                                              onclick="toggleMonsterSpellSlot(${level}, ${i})"></div>`;
                            }

                            html += `</div></div>`;
                        }
                    }
                    html += `</div>`;
                } else if (abilities.spellcastingType === 'per-day') {
                    // Per-day spells - group by maxUses
                    const spellGroups = {};
                    abilities.perDaySpells.forEach((spell, index) => {
                        const key = spell.maxUses === 999 ? 'At Will' : `${spell.maxUses}/Day`;
                        if (!spellGroups[key]) {
                            spellGroups[key] = [];
                        }
                        spellGroups[key].push({ ...spell, index });
                    });

                    // Display groups in order: At Will, 3/Day, 2/Day, 1/Day
                    const groupOrder = ['At Will', '3/Day', '2/Day', '1/Day'];
                    groupOrder.forEach(groupKey => {
                        if (spellGroups[groupKey]) {
                            html += `
                                <div style="margin: 15px 0;">
                                    <h4 style="color: #7f8c8d; margin-bottom: 10px;">${groupKey}</h4>
                                    <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                            `;

                            spellGroups[groupKey].forEach(spell => {
                                if (spell.maxUses === 999) {
                                    // At will - just show spell name
                                    html += `
                                        <div style="padding: 8px 15px; background: #ecf0f1; border-radius: 5px; color: #2c3e50;">
                                            ${spell.name}
                                        </div>
                                    `;
                                } else {
                                    // Limited uses - show with usage tracking
                                    const allUsed = spell.used >= spell.maxUses;
                                    html += `
                                        <div style="padding: 8px 15px; background: ${allUsed ? '#ffebee' : '#e8f5e9'};
                                             border-radius: 5px; cursor: pointer; border: 2px solid ${allUsed ? '#ef5350' : '#66bb6a'};"
                                             onclick="togglePerDaySpell(${spell.index})">
                                            <div style="font-weight: bold; color: #2c3e50;">${spell.name}</div>
                                            <div style="font-size: 0.85em; color: #7f8c8d;">${spell.used}/${spell.maxUses} pou≈æito</div>
                                        </div>
                                    `;
                                }
                            });

                            html += `</div></div>`;
                        }
                    });

                    // Show other groups that might exist
                    Object.keys(spellGroups).forEach(groupKey => {
                        if (!groupOrder.includes(groupKey)) {
                            html += `
                                <div style="margin: 15px 0;">
                                    <h4 style="color: #7f8c8d; margin-bottom: 10px;">${groupKey}</h4>
                                    <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                            `;

                            spellGroups[groupKey].forEach(spell => {
                                const allUsed = spell.used >= spell.maxUses;
                                html += `
                                    <div style="padding: 8px 15px; background: ${allUsed ? '#ffebee' : '#e8f5e9'};
                                         border-radius: 5px; cursor: pointer; border: 2px solid ${allUsed ? '#ef5350' : '#66bb6a'};"
                                         onclick="togglePerDaySpell(${spell.index})">
                                        <div style="font-weight: bold; color: #2c3e50;">${spell.name}</div>
                                        <div style="font-size: 0.85em; color: #7f8c8d;">${spell.used}/${spell.maxUses} pou≈æito</div>
                                    </div>
                                `;
                            });

                            html += `</div></div>`;
                        }
                    });
                }
            }

            // Custom Features Section
            html += `
                <h3 style="margin: 30px 0 15px 0;">üéØ Custom Features & Abilities</h3>
                <div class="custom-features-container">
            `;

            if (abilities.customFeatures && abilities.customFeatures.length > 0) {
                abilities.customFeatures.forEach((feature, index) => {
                    html += `
                        <div class="feature-item">
                            <div class="feature-info">
                                <div class="feature-name">${feature.name}</div>
                                <div class="feature-meta">${feature.used}/${feature.maxUses} pou≈æito</div>
                            </div>
                            <div class="feature-uses">
                    `;

                    if (feature.maxUses > 10) {
                        const usagePercent = (feature.used / feature.maxUses) * 100;
                        const barColorClass = usagePercent >= 75 ? 'low' : usagePercent >= 50 ? 'medium' : '';
                        html += `
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <button class="control-btn btn-success" onclick="changeMonsterFeatureUses(${index}, -1)">-1</button>
                                <div style="flex: 1; min-width: 150px;">
                                    <div class="hp-bar">
                                        <div class="hp-fill ${barColorClass}" style="width: ${usagePercent}%"></div>
                                    </div>
                                </div>
                                <input type="number" class="custom-input" min="0" max="${feature.maxUses}" value="${feature.used}"
                                       onchange="setMonsterFeatureUses(${index}, this.value)" style="width: 60px;">
                                <button class="control-btn btn-danger" onclick="changeMonsterFeatureUses(${index}, 1)">+1</button>
                            </div>
                        `;
                    } else {
                        for (let i = 0; i < feature.maxUses; i++) {
                            const used = i < feature.used;
                            html += `<div class="use-checkbox ${used ? 'used' : ''}" onclick="toggleMonsterCustomFeature(${index}, ${i})"></div>`;
                        }
                    }

                    html += `</div></div>`;
                });
            } else {
                html += '<p style="color: #7f8c8d; text-align: center; padding: 20px;">≈Ω√°dn√© custom features pro toto monstrum.</p>';
            }

            html += `</div>`;

            html += `
                <div style="margin-top: 30px; padding: 15px; background: #e8f5e9; border-radius: 8px;">
                    <p style="color: #2e7d32; margin: 0;">
                        <strong>‚ÑπÔ∏è Pozn√°mka:</strong> Monster Ability Tracker je v z√°kladn√≠ verzi.
                        Konfigurace abilities (p≈ôid√°n√≠/√∫prava) zat√≠m prob√≠h√° p≈ôes datab√°zi monster a import funkci.
                        Per-day spellcasting a pln√Ω auto-parser budou p≈ôid√°ny v dal≈°√≠ verzi.
                    </p>
                </div>
            `;

            document.getElementById('monsterAbilityContent').innerHTML = html;
        }

        // Helper functions for monster abilities
        function changeLegendaryActions(change) {
            const monster = characters.find(c => c.id === currentMonsterCharacterId);
            if (!monster || !monster.monsterAbilities) return;

            const la = monster.monsterAbilities.legendaryActions;
            la.used = Math.max(0, Math.min(la.max, la.used + change));

            renderMonsterAbilities();
            syncToServer();
            saveToLocalStorage();
        }

        function toggleMonsterSpellSlot(level, slotIndex) {
            const monster = characters.find(c => c.id === currentMonsterCharacterId);
            if (!monster || !monster.monsterAbilities || !monster.monsterAbilities.spellSlots[level]) return;

            const slots = monster.monsterAbilities.spellSlots[level];

            if (slotIndex < slots.used) {
                slots.used = slotIndex;
            } else {
                slots.used = slotIndex + 1;
            }

            renderMonsterAbilities();
            syncToServer();
            saveToLocalStorage();
        }

        function updateMonsterSpellSlotMax(level, newMax) {
            const monster = characters.find(c => c.id === currentMonsterCharacterId);
            if (!monster || !monster.monsterAbilities) return;

            newMax = parseInt(newMax) || 0;
            if (!monster.monsterAbilities.spellSlots[level]) {
                monster.monsterAbilities.spellSlots[level] = { max: 0, used: 0 };
            }

            monster.monsterAbilities.spellSlots[level].max = newMax;
            monster.monsterAbilities.spellSlots[level].used = Math.min(
                monster.monsterAbilities.spellSlots[level].used,
                newMax
            );

            renderMonsterAbilities();
            syncToServer();
            saveToLocalStorage();
        }

        function changeMonsterFeatureUses(featureIndex, change) {
            const monster = characters.find(c => c.id === currentMonsterCharacterId);
            if (!monster || !monster.monsterAbilities || !monster.monsterAbilities.customFeatures[featureIndex]) return;

            const feature = monster.monsterAbilities.customFeatures[featureIndex];
            feature.used = Math.max(0, Math.min(feature.maxUses, feature.used + change));

            renderMonsterAbilities();
            syncToServer();
            saveToLocalStorage();
        }

        function setMonsterFeatureUses(featureIndex, value) {
            const monster = characters.find(c => c.id === currentMonsterCharacterId);
            if (!monster || !monster.monsterAbilities || !monster.monsterAbilities.customFeatures[featureIndex]) return;

            const feature = monster.monsterAbilities.customFeatures[featureIndex];
            feature.used = Math.max(0, Math.min(feature.maxUses, parseInt(value) || 0));

            renderMonsterAbilities();
            syncToServer();
            saveToLocalStorage();
        }

        function toggleMonsterCustomFeature(featureIndex, useIndex) {
            const monster = characters.find(c => c.id === currentMonsterCharacterId);
            if (!monster || !monster.monsterAbilities || !monster.monsterAbilities.customFeatures[featureIndex]) return;

            const feature = monster.monsterAbilities.customFeatures[featureIndex];

            if (useIndex < feature.used) {
                feature.used = useIndex;
            } else {
                feature.used = useIndex + 1;
            }

            renderMonsterAbilities();
            syncToServer();
            saveToLocalStorage();
        }

        function togglePerDaySpell(spellIndex) {
            const monster = characters.find(c => c.id === currentMonsterCharacterId);
            if (!monster || !monster.monsterAbilities || !monster.monsterAbilities.perDaySpells[spellIndex]) return;

            const spell = monster.monsterAbilities.perDaySpells[spellIndex];

            if (spell.used >= spell.maxUses) {
                spell.used = 0;
            } else {
                spell.used++;
            }

            renderMonsterAbilities();
            syncToServer();
            saveToLocalStorage();
        }

        function adjustMonsterPower(change) {
            const monster = characters.find(c => c.id === currentMonsterCharacterId);
            if (!monster) return;

            monster.currentPower = Math.max(0, Math.min(monster.maxPower || 0, (monster.currentPower || 0) + change));

            renderMonsterAbilities();
            renderCharacters();
            syncToServer();
            saveToLocalStorage();
        }

        // Open character sheet from character card
        function openCharacterSheet(characterId) {
            // Switch to spells page
            switchPage('spells');
            // Set the dropdown value
            document.getElementById('spellCharacterSelect').value = characterId;
            // Load the character
            loadSpellCharacter();
        }

        // Open monster abilities sheet from character card
        function openMonsterSheet(characterId) {
            // Switch to monsters page
            switchPage('monsters');
            // Set the dropdown value
            document.getElementById('monsterCharacterSelect').value = characterId;
            // Load the monster
            loadMonsterCharacter();
        }

        function showEmptySpellState() {
            document.getElementById('spellTrackingContent').innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">üé≠</div>
                    <h3>Vyberte postavu</h3>
                    <p>Zvolte postavu ze seznamu v√Ω≈°e pro spr√°vu spell slot≈Ø a abilities</p>
                </div>
            `;
        }

        // Render spell tracking for current character
        function renderSpellTracking() {
            const character = characters.find(c => c.id === currentSpellCharacterId);
            if (!character) {
                showEmptySpellState();
                return;
            }

            // Initialize spell slots if needed
            if (!character.spellSlots || Object.keys(character.spellSlots).length === 0) {
                updateSpellSlotsForLevel(character);
            }

            let html = '';

            // Spell Slots Section
            if (character.spellcasterLevel > 0) {
                html += '<h3 style="margin-bottom: 15px;">‚ú® Spell Sloty</h3>';
                html += '<div class="spell-slots-container">';

                const maxLevel = character.spellcasterLevel > 20 ? 12 : 9;
                for (let level = 1; level <= maxLevel; level++) {
                    const slots = character.spellSlots[level];
                    if (slots && slots.max > 0) {
                        let levelName = level <= 9 ? `Level ${level}` : `Epic ${level - 9}`;
                        html += `
                            <div class="spell-level-group">
                                <div class="spell-level-title">${levelName} (${slots.max - slots.used}/${slots.max})</div>
                                <div class="spell-slots">
                        `;
                        for (let i = 0; i < slots.max; i++) {
                            const used = i < slots.used;
                            html += `<div class="spell-slot ${used ? 'used' : ''}" onclick="toggleSpellSlot(${level}, ${i})"></div>`;
                        }
                        html += `
                                </div>
                            </div>
                        `;
                    }
                }

                html += '</div>';
            } else {
                html += '<p style="color: #7f8c8d; text-align: center; padding: 20px;">Postava nem√° nastaven√Ω spellcaster level</p>';
            }

            // Hit Dice Section
            html += `
                <h3 style="margin-bottom: 15px; margin-top: 30px;">üé≤ Hit Dice</h3>
                <div class="hit-dice-container">
                    <div class="hit-dice-display">
                        <div class="hit-dice-title">${character.hitDice.current}/${character.hitDice.max} dostupn√Ωch</div>
                        <div class="hit-dice-controls">
            `;
            for (let i = 0; i < character.hitDice.max; i++) {
                // Pou≈æit√© dice jsou PRVN√ç (zleva), dostupn√© POSLEDN√ç (zprava)
                const used = i < (character.hitDice.max - character.hitDice.current);
                html += `<div class="hit-die ${used ? 'used' : ''}" onclick="toggleHitDie(${i})">d</div>`;
            }
            html += `
                        </div>
                    </div>
                </div>
            `;

            // Custom Features Section
            html += `
                <h3 style="margin-bottom: 15px; margin-top: 30px;">üéØ Custom Features & Abilities</h3>
                <div class="custom-features-container">
            `;

            if (character.customFeatures && character.customFeatures.length > 0) {
                character.customFeatures.forEach((feature, index) => {
                    const available = feature.maxUses - feature.used;

                    // Build rest type string
                    let restInfo = [];
                    const srType = feature.shortRestRegainType || (feature.restType === 'short' ? feature.regainType : 'none');
                    const lrType = feature.longRestRegainType || (feature.restType === 'long' ? feature.regainType : 'none');

                    if (srType && srType !== 'none') {
                        const srAmount = feature.shortRestRegainAmount || feature.regainAmount || 0;
                        restInfo.push(`SR: ${srType === 'all' ? 'all' : srType === 'fixed' ? srAmount : 'input'}`);
                    }
                    if (lrType && lrType !== 'none') {
                        const lrAmount = feature.longRestRegainAmount || feature.regainAmount || 0;
                        restInfo.push(`LR: ${lrType === 'all' ? 'all' : lrType === 'fixed' ? lrAmount : 'input'}`);
                    }
                    const restTypeStr = restInfo.length > 0 ? restInfo.join(', ') : 'None';

                    html += `
                        <div class="feature-item">
                            <div class="feature-info">
                                <div class="feature-name">${feature.name}</div>
                                <div class="feature-meta">
                                    ${feature.used}/${feature.maxUses} pou≈æito ‚Ä¢ Obnoven√≠: ${restTypeStr}
                                    ${feature.statusEffect ? ` ‚Ä¢ Status: ${feature.statusName}` : ''}
                                </div>
                            </div>
                            <div class="feature-uses">
                    `;

                    // If maxUses > 10, use health bar instead of checkboxes
                    if (feature.maxUses > 10) {
                        const usagePercent = (feature.used / feature.maxUses) * 100;
                        const barColorClass = usagePercent >= 75 ? 'low' : usagePercent >= 50 ? 'medium' : '';
                        html += `
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <button class="control-btn btn-success" onclick="changeFeatureUses(${index}, -1)">-1</button>
                                <div style="flex: 1; min-width: 150px;">
                                    <div class="hp-bar">
                                        <div class="hp-fill ${barColorClass}"
                                             style="width: ${usagePercent}%"></div>
                                    </div>
                                </div>
                                <input type="number" class="custom-input" min="0" max="${feature.maxUses}" value="${feature.used}"
                                       onchange="setFeatureUses(${index}, this.value)" style="width: 60px;">
                                <button class="control-btn btn-danger" onclick="changeFeatureUses(${index}, 1)">+1</button>
                            </div>
                        `;
                    } else {
                        // Use checkboxes for <= 10 uses
                        for (let i = 0; i < feature.maxUses; i++) {
                            const used = i < feature.used;
                            html += `<div class="use-checkbox ${used ? 'used' : ''}" onclick="toggleCustomFeature(${index}, ${i})"></div>`;
                        }
                    }

                    html += `
                            </div>
                        </div>
                    `;
                });
            } else {
                html += '<p style="color: #7f8c8d; text-align: center; padding: 20px;">≈Ω√°dn√© custom features. Kliknƒõte na "Upravit" pro p≈ôid√°n√≠.</p>';
            }

            html += '</div>';

            // Rest Buttons
            html += `
                <div class="rest-buttons">
                    <button class="rest-btn btn-warning" onclick="shortRest()">üåô Short Rest</button>
                    <button class="rest-btn btn-success" onclick="longRest()">‚òÄÔ∏è Long Rest</button>
                </div>
            `;

            document.getElementById('spellTrackingContent').innerHTML = html;
        }

        // Update spell slots based on character level
        function updateSpellSlotsForLevel(character) {
            const level = character.spellcasterLevel || 0;
            if (level === 0) {
                character.spellSlots = {};
                return;
            }

            const slotsArray = SPELL_SLOTS_TABLE[level] || [];
            const newSlots = {};

            for (let i = 0; i < slotsArray.length; i++) {
                const slotLevel = i + 1;
                const maxSlots = slotsArray[i];
                if (maxSlots > 0) {
                    // Preserve used count if it exists
                    const existingUsed = character.spellSlots[slotLevel]?.used || 0;
                    newSlots[slotLevel] = {
                        max: maxSlots,
                        used: Math.min(existingUsed, maxSlots) // Don't exceed new max
                    };
                }
            }

            character.spellSlots = newSlots;
        }

        // Toggle spell slot
        function toggleSpellSlot(level, slotIndex) {
            saveState();
            const character = characters.find(c => c.id === currentSpellCharacterId);
            if (!character || !character.spellSlots[level]) return;

            const slots = character.spellSlots[level];

            // If clicking used slot, decrease used count
            if (slotIndex < slots.used) {
                slots.used = slotIndex;
            } else {
                // If clicking unused slot, mark up to this slot as used
                slots.used = slotIndex + 1;
            }

            renderSpellTracking();
            syncToServer();
            saveToLocalStorage();
        }

        // Toggle hit die
        function toggleHitDie(dieIndex) {
            saveState();
            const character = characters.find(c => c.id === currentSpellCharacterId);
            if (!character) return;

            const usedCount = character.hitDice.max - character.hitDice.current;

            // If clicking used die (pln√°), restore from this die onwards
            if (dieIndex < usedCount) {
                // Set current so that this die becomes the first available one
                character.hitDice.current = character.hitDice.max - dieIndex;
            } else {
                // If clicking available die (pr√°zdn√°), use up to this die
                character.hitDice.current = character.hitDice.max - dieIndex - 1;
            }

            renderSpellTracking();
            syncToServer();
            saveToLocalStorage();
        }

        // Toggle custom feature use
        function toggleCustomFeature(featureIndex, useIndex) {
            saveState();
            const character = characters.find(c => c.id === currentSpellCharacterId);
            if (!character || !character.customFeatures[featureIndex]) return;

            const feature = character.customFeatures[featureIndex];

            // If clicking used checkbox, decrease used count
            if (useIndex < feature.used) {
                feature.used = useIndex;

                // Remove status effect if exists
                if (feature.statusEffect && feature.statusName) {
                    const effectIndex = character.effects.findIndex(e => {
                        const eName = typeof e === 'string' ? e : e.name;
                        return eName === feature.statusName;
                    });
                    if (effectIndex !== -1) {
                        character.effects.splice(effectIndex, 1);
                    }
                }
            } else {
                // If clicking unused checkbox, mark as used
                feature.used = useIndex + 1;

                // Add status effect if configured and character doesn't have it
                if (feature.statusEffect && feature.statusName) {
                    const hasEffect = character.effects.some(e => {
                        const eName = typeof e === 'string' ? e : e.name;
                        return eName === feature.statusName;
                    });
                    if (!hasEffect) {
                        character.effects.push(feature.statusName);
                    }
                }
            }

            renderSpellTracking();
            renderCharacters(); // Update main character list to show effects
            syncToServer();
            saveToLocalStorage();
        }

        // Change feature uses (for health bar +/- buttons)
        function changeFeatureUses(featureIndex, change) {
            saveState();
            const character = characters.find(c => c.id === currentSpellCharacterId);
            if (!character || !character.customFeatures[featureIndex]) return;

            const feature = character.customFeatures[featureIndex];
            const newUsed = Math.max(0, Math.min(feature.maxUses, feature.used + change));

            // Handle status effects
            if (newUsed > 0 && feature.statusEffect && feature.statusName) {
                // If any uses - add status if not present
                const hasEffect = character.effects.some(e => {
                    const eName = typeof e === 'string' ? e : e.name;
                    return eName === feature.statusName;
                });
                if (!hasEffect) {
                    character.effects.push(feature.statusName);
                }
            } else if (newUsed === 0 && feature.used > 0 && feature.statusEffect && feature.statusName) {
                // Removing all uses - remove status
                const effectIndex = character.effects.findIndex(e => {
                    const eName = typeof e === 'string' ? e : e.name;
                    return eName === feature.statusName;
                });
                if (effectIndex !== -1) {
                    character.effects.splice(effectIndex, 1);
                }
            }

            feature.used = newUsed;

            renderSpellTracking();
            renderCharacters();
            syncToServer();
            saveToLocalStorage();
        }

        // Set feature uses directly (for custom input)
        function setFeatureUses(featureIndex, value) {
            saveState();
            const character = characters.find(c => c.id === currentSpellCharacterId);
            if (!character || !character.customFeatures[featureIndex]) return;

            const feature = character.customFeatures[featureIndex];
            const newUsed = Math.max(0, Math.min(feature.maxUses, parseInt(value) || 0));
            const oldUsed = feature.used;

            // Handle status effects
            if (newUsed > 0 && feature.statusEffect && feature.statusName) {
                // If any uses - add status if not present
                const hasEffect = character.effects.some(e => {
                    const eName = typeof e === 'string' ? e : e.name;
                    return eName === feature.statusName;
                });
                if (!hasEffect) {
                    character.effects.push(feature.statusName);
                }
            } else if (newUsed === 0 && oldUsed > 0 && feature.statusEffect && feature.statusName) {
                // Removing all uses - remove status
                const effectIndex = character.effects.findIndex(e => {
                    const eName = typeof e === 'string' ? e : e.name;
                    return eName === feature.statusName;
                });
                if (effectIndex !== -1) {
                    character.effects.splice(effectIndex, 1);
                }
            }

            feature.used = newUsed;

            renderSpellTracking();
            renderCharacters();
            syncToServer();
            saveToLocalStorage();
        }

        // Short Rest
        function shortRest() {
            saveState();
            const character = characters.find(c => c.id === currentSpellCharacterId);
            if (!character) return;

            if (!confirm(`Prov√©st Short Rest pro ${character.name}?\n\nObnov√≠: Short Rest features`)) {
                return;
            }

            // Restore short rest features
            if (character.customFeatures) {
                character.customFeatures.forEach(feature => {
                    const regainType = feature.shortRestRegainType || (feature.restType === 'short' ? feature.regainType : 'none');
                    if (regainType && regainType !== 'none') {
                        if (regainType === 'all') {
                            feature.used = 0;
                        } else if (regainType === 'fixed') {
                            const amount = feature.shortRestRegainAmount || feature.regainAmount || 0;
                            feature.used = Math.max(0, feature.used - amount);
                        } else if (regainType === 'input') {
                            const amount = feature.shortRestRegainAmount || feature.regainAmount || 1;
                            const regained = parseInt(prompt(`Kolik ${feature.name} se obnov√≠? (aktu√°lnƒõ pou≈æito: ${feature.used})`, amount));
                            if (!isNaN(regained)) {
                                feature.used = Math.max(0, feature.used - regained);
                            }
                        }
                    }
                });
            }

            renderSpellTracking();
            syncToServer();
            saveToLocalStorage();
            alert('Short Rest dokonƒçen!');
        }

        // Long Rest
        function longRest() {
            saveState();
            const character = characters.find(c => c.id === currentSpellCharacterId);
            if (!character) return;

            if (!confirm(`Prov√©st Long Rest pro ${character.name}?\n\nObnov√≠: HP, spell sloty, long rest features a hit dice`)) {
                return;
            }

            // Restore HP
            character.currentHp = character.maxHp;
            character.tempHp = 0;

            // Restore all spell slots
            Object.keys(character.spellSlots).forEach(level => {
                character.spellSlots[level].used = 0;
            });

            // Restore long rest features
            if (character.customFeatures) {
                character.customFeatures.forEach(feature => {
                    const regainType = feature.longRestRegainType || (feature.restType === 'long' ? feature.regainType : 'none');
                    if (regainType && regainType !== 'none') {
                        if (regainType === 'all') {
                            feature.used = 0;
                        } else if (regainType === 'fixed') {
                            const amount = feature.longRestRegainAmount || feature.regainAmount || 0;
                            feature.used = Math.max(0, feature.used - amount);
                        } else if (regainType === 'input') {
                            const amount = feature.longRestRegainAmount || feature.regainAmount || 1;
                            const regained = parseInt(prompt(`Kolik ${feature.name} se obnov√≠? (aktu√°lnƒõ pou≈æito: ${feature.used})`, amount));
                            if (!isNaN(regained)) {
                                feature.used = Math.max(0, feature.used - regained);
                            }
                        }
                    }
                });
            }

            // Restore hit dice (restore half of max, aditivnƒõ)
            const regainAmount = Math.max(1, Math.floor(character.hitDice.max / 2));
            character.hitDice.current = Math.min(character.hitDice.max, character.hitDice.current + regainAmount);

            renderSpellTracking();
            renderCharacters(); // Update main character list
            syncToServer();
            saveToLocalStorage();
            alert('Long Rest dokonƒçen!');
        }

        // Open edit modal
        function openEditSpellCharacter() {
            const character = characters.find(c => c.id === currentSpellCharacterId);
            if (!character) return;

            document.getElementById('editSpellCharName').textContent = character.name;
            document.getElementById('spellcasterLevelInput').value = character.spellcasterLevel || 0;
            document.getElementById('hitDiceMaxInput').value = character.hitDice?.max || 0;

            // Render custom features editor
            renderCustomFeaturesEditor();

            document.getElementById('editSpellCharacterModal').style.display = 'block';
        }

        function closeEditSpellCharacter() {
            document.getElementById('editSpellCharacterModal').style.display = 'none';
        }

        function renderCustomFeaturesEditor() {
            const character = characters.find(c => c.id === currentSpellCharacterId);
            if (!character) return;

            const container = document.getElementById('customFeaturesEditor');
            let html = '';

            if (character.customFeatures && character.customFeatures.length > 0) {
                character.customFeatures.forEach((feature, index) => {
                    // Backward compatibility - convert old format to new
                    if (feature.restType && !feature.shortRestRegainType) {
                        if (feature.restType === 'short') {
                            feature.shortRestRegainType = feature.regainType || 'all';
                            feature.shortRestRegainAmount = feature.regainAmount || 0;
                            feature.longRestRegainType = 'none';
                            feature.longRestRegainAmount = 0;
                        } else {
                            feature.shortRestRegainType = 'none';
                            feature.shortRestRegainAmount = 0;
                            feature.longRestRegainType = feature.regainType || 'all';
                            feature.longRestRegainAmount = feature.regainAmount || 0;
                        }
                    }

                    html += `
                        <div class="feature-editor">
                            <div class="feature-editor-row">
                                <input type="text" placeholder="N√°zev feature" value="${feature.name}" id="featureName${index}">
                                <input type="number" placeholder="Max uses" value="${feature.maxUses}" id="featureMaxUses${index}" min="1">
                            </div>
                            <div class="feature-editor-row">
                                <label style="font-weight: bold; font-size: 0.9em; width: 100%;">Short Rest:</label>
                            </div>
                            <div class="feature-editor-row">
                                <select id="featureShortRestRegainType${index}">
                                    <option value="none" ${feature.shortRestRegainType === 'none' ? 'selected' : ''}>None</option>
                                    <option value="all" ${feature.shortRestRegainType === 'all' ? 'selected' : ''}>V≈°echny</option>
                                    <option value="fixed" ${feature.shortRestRegainType === 'fixed' ? 'selected' : ''}>Fixn√≠ poƒçet</option>
                                    <option value="input" ${feature.shortRestRegainType === 'input' ? 'selected' : ''}>Zad√°n√≠ hr√°ƒçem</option>
                                </select>
                                <input type="number" placeholder="Poƒçet" value="${feature.shortRestRegainAmount || 0}" id="featureShortRestRegainAmount${index}" min="0">
                            </div>
                            <div class="feature-editor-row">
                                <label style="font-weight: bold; font-size: 0.9em; width: 100%;">Long Rest:</label>
                            </div>
                            <div class="feature-editor-row">
                                <select id="featureLongRestRegainType${index}">
                                    <option value="none" ${feature.longRestRegainType === 'none' ? 'selected' : ''}>None</option>
                                    <option value="all" ${feature.longRestRegainType === 'all' ? 'selected' : ''}>V≈°echny</option>
                                    <option value="fixed" ${feature.longRestRegainType === 'fixed' ? 'selected' : ''}>Fixn√≠ poƒçet</option>
                                    <option value="input" ${feature.longRestRegainType === 'input' ? 'selected' : ''}>Zad√°n√≠ hr√°ƒçem</option>
                                </select>
                                <input type="number" placeholder="Poƒçet" value="${feature.longRestRegainAmount || 0}" id="featureLongRestRegainAmount${index}" min="0">
                            </div>
                            <div class="feature-editor-row">
                                <label style="font-weight: bold; font-size: 0.9em; width: 100%;">Status Effect:</label>
                            </div>
                            <div class="feature-editor-row">
                                <select id="featureStatusName${index}" style="flex: 2;">
                                    <option value="">-- ≈Ω√°dn√Ω status --</option>
                                    <optgroup label="üî¥ Debuffs">
                                        <option value="Blinded" ${feature.statusName === 'Blinded' ? 'selected' : ''}>Blinded</option>
                                        <option value="Charmed" ${feature.statusName === 'Charmed' ? 'selected' : ''}>Charmed</option>
                                        <option value="Deafened" ${feature.statusName === 'Deafened' ? 'selected' : ''}>Deafened</option>
                                        <option value="Exhaustion" ${feature.statusName === 'Exhaustion' ? 'selected' : ''}>Exhaustion</option>
                                        <option value="Frightened" ${feature.statusName === 'Frightened' ? 'selected' : ''}>Frightened</option>
                                        <option value="Grappled" ${feature.statusName === 'Grappled' ? 'selected' : ''}>Grappled</option>
                                        <option value="Incapacitated" ${feature.statusName === 'Incapacitated' ? 'selected' : ''}>Incapacitated</option>
                                        <option value="Paralyzed" ${feature.statusName === 'Paralyzed' ? 'selected' : ''}>Paralyzed</option>
                                        <option value="Petrified" ${feature.statusName === 'Petrified' ? 'selected' : ''}>Petrified</option>
                                        <option value="Poisoned" ${feature.statusName === 'Poisoned' ? 'selected' : ''}>Poisoned</option>
                                        <option value="Prone" ${feature.statusName === 'Prone' ? 'selected' : ''}>Prone</option>
                                        <option value="Restrained" ${feature.statusName === 'Restrained' ? 'selected' : ''}>Restrained</option>
                                        <option value="Stunned" ${feature.statusName === 'Stunned' ? 'selected' : ''}>Stunned</option>
                                        <option value="Unconscious" ${feature.statusName === 'Unconscious' ? 'selected' : ''}>Unconscious</option>
                                        <option value="Defenseless" ${feature.statusName === 'Defenseless' ? 'selected' : ''}>Defenseless</option>
                                        <option value="Impaired" ${feature.statusName === 'Impaired' ? 'selected' : ''}>Impaired</option>
                                        <option value="Distracted" ${feature.statusName === 'Distracted' ? 'selected' : ''}>Distracted</option>
                                        <option value="Hexblade_Curse" ${feature.statusName === 'Hexblade_Curse' ? 'selected' : ''}>Hexblade's Curse</option>
                                        <option value="Moonlit" ${feature.statusName === 'Moonlit' ? 'selected' : ''}>Moonlit</option>
                                        <option value="Confused" ${feature.statusName === 'Confused' ? 'selected' : ''}>Confused</option>
                                        <option value="Divine_Ire" ${feature.statusName === 'Divine_Ire' ? 'selected' : ''}>Divine Ire</option>
                                        <option value="Divine_Ire_Cyric" ${feature.statusName === 'Divine_Ire_Cyric' ? 'selected' : ''}>Divine Ire (Cyric)</option>
                                    </optgroup>
                                    <optgroup label="üü¢ Buffs">
                                        <option value="Hasted" ${feature.statusName === 'Hasted' ? 'selected' : ''}>Hasted</option>
                                        <option value="Inspired" ${feature.statusName === 'Inspired' ? 'selected' : ''}>Inspired</option>
                                        <option value="Invisible" ${feature.statusName === 'Invisible' ? 'selected' : ''}>Invisible</option>
                                        <option value="Raging" ${feature.statusName === 'Raging' ? 'selected' : ''}>Raging</option>
                                        <option value="Dodging" ${feature.statusName === 'Dodging' ? 'selected' : ''}>Dodging</option>
                                        <option value="Heroic_Inspiration" ${feature.statusName === 'Heroic_Inspiration' ? 'selected' : ''}>Heroic Inspiration</option>
                                        <option value="Spirit_Shroud" ${feature.statusName === 'Spirit_Shroud' ? 'selected' : ''}>Spirit Shroud</option>
                                        <option value="Tensor_Transformation" ${feature.statusName === 'Tensor_Transformation' ? 'selected' : ''}>Tensor Transformation</option>
                                        <option value="Retaliation_Aura" ${feature.statusName === 'Retaliation_Aura' ? 'selected' : ''}>Retaliation Aura</option>
                                        <option value="Foresight" ${feature.statusName === 'Foresight' ? 'selected' : ''}>Foresight</option>
                                        <option value="Elder_Champion" ${feature.statusName === 'Elder_Champion' ? 'selected' : ''}>Elder Champion</option>
                                        <option value="Celestial_Revelation" ${feature.statusName === 'Celestial_Revelation' ? 'selected' : ''}>Celestial Revelation</option>
                                        <option value="Power_of_Mercy" ${feature.statusName === 'Power_of_Mercy' ? 'selected' : ''}>Power of Mercy</option>
                                        <option value="Sacred_Divine_Sense" ${feature.statusName === 'Sacred_Divine_Sense' ? 'selected' : ''}>Sacred Divine Sense</option>
                                        <option value="Protective_Spirit" ${feature.statusName === 'Protective_Spirit' ? 'selected' : ''}>Protective Spirit</option>
                                        <option value="Emissary_of_Redemtion" ${feature.statusName === 'Emissary_of_Redemtion' ? 'selected' : ''}>Emissary of Redemtion</option>
                                        <option value="Rythm_of_War" ${feature.statusName === 'Rythm_of_War' ? 'selected' : ''}>Rythm of War</option>
                                    </optgroup>
                                    <optgroup label="üîµ Neutr√°ln√≠">
                                        <option value="Concentrating" ${feature.statusName === 'Concentrating' ? 'selected' : ''}>Concentrating</option>
                                        <option value="Marked" ${feature.statusName === 'Marked' ? 'selected' : ''}>Marked</option>
                                        <option value="Irredeemable" ${feature.statusName === 'Irredeemable' ? 'selected' : ''}>Irredeemable</option>
                                        <option value="Not_Harmonized" ${feature.statusName === 'Not_Harmonized' ? 'selected' : ''}>Not Harmonized</option>
                                    </optgroup>
                                </select>
                                <button class="remove-feature-btn" onclick="removeCustomFeature(${index})">‚ùå Odebrat</button>
                            </div>
                        </div>
                    `;
                });
            } else {
                html = '<p style="color: #7f8c8d; text-align: center; padding: 10px;">≈Ω√°dn√© features</p>';
            }

            container.innerHTML = html;
        }

        function addCustomFeatureEditor() {
            const character = characters.find(c => c.id === currentSpellCharacterId);
            if (!character) return;

            if (!character.customFeatures) {
                character.customFeatures = [];
            }

            character.customFeatures.push({
                name: 'Nov√° Feature',
                maxUses: 1,
                used: 0,
                shortRestRegainType: 'none',
                shortRestRegainAmount: 0,
                longRestRegainType: 'all',
                longRestRegainAmount: 0,
                statusEffect: '',
                statusName: ''
            });

            renderCustomFeaturesEditor();
        }

        function removeCustomFeature(index) {
            const character = characters.find(c => c.id === currentSpellCharacterId);
            if (!character) return;

            if (confirm('Opravdu chcete odstranit tuto feature?')) {
                character.customFeatures.splice(index, 1);
                renderCustomFeaturesEditor();
            }
        }

        function saveSpellCharacter() {
            saveState();
            const character = characters.find(c => c.id === currentSpellCharacterId);
            if (!character) return;

            // Save spellcaster level
            const newLevel = parseInt(document.getElementById('spellcasterLevelInput').value) || 0;
            character.spellcasterLevel = newLevel;
            updateSpellSlotsForLevel(character);

            // Save hit dice
            const newHitDiceMax = parseInt(document.getElementById('hitDiceMaxInput').value) || 0;
            const oldMax = character.hitDice.max;
            character.hitDice.max = newHitDiceMax;
            // Adjust current if max changed
            if (newHitDiceMax < character.hitDice.current) {
                character.hitDice.current = newHitDiceMax;
            } else if (newHitDiceMax > oldMax) {
                // Increase current proportionally
                character.hitDice.current = Math.min(newHitDiceMax, character.hitDice.current + (newHitDiceMax - oldMax));
            }

            // Save custom features
            if (character.customFeatures) {
                character.customFeatures.forEach((feature, index) => {
                    const nameInput = document.getElementById(`featureName${index}`);
                    const maxUsesInput = document.getElementById(`featureMaxUses${index}`);
                    const shortRestRegainTypeSelect = document.getElementById(`featureShortRestRegainType${index}`);
                    const shortRestRegainAmountInput = document.getElementById(`featureShortRestRegainAmount${index}`);
                    const longRestRegainTypeSelect = document.getElementById(`featureLongRestRegainType${index}`);
                    const longRestRegainAmountInput = document.getElementById(`featureLongRestRegainAmount${index}`);
                    const statusNameSelect = document.getElementById(`featureStatusName${index}`);

                    if (nameInput) feature.name = nameInput.value;
                    if (maxUsesInput) {
                        const newMax = parseInt(maxUsesInput.value) || 1;
                        feature.maxUses = newMax;
                        // Adjust used if it exceeds new max
                        if (feature.used > newMax) {
                            feature.used = newMax;
                        }
                    }
                    if (shortRestRegainTypeSelect) feature.shortRestRegainType = shortRestRegainTypeSelect.value;
                    if (shortRestRegainAmountInput) feature.shortRestRegainAmount = parseInt(shortRestRegainAmountInput.value) || 0;
                    if (longRestRegainTypeSelect) feature.longRestRegainType = longRestRegainTypeSelect.value;
                    if (longRestRegainAmountInput) feature.longRestRegainAmount = parseInt(longRestRegainAmountInput.value) || 0;
                    if (statusNameSelect) {
                        feature.statusName = statusNameSelect.value;
                        feature.statusEffect = statusNameSelect.value ? true : false;
                    }
                });
            }

            closeEditSpellCharacter();
            renderSpellTracking();
            syncToServer();
            saveToLocalStorage();
            alert('Zmƒõny ulo≈æeny!');
        }

        // Initialize WebSocket
        initializeWebSocket();

        // Setup UI based on mode
        setupPlayerMode();
    </script>
</body>
</html>